/*
 * NOTE: This file is autogenerated by cbindgen.
 *
 * Foxglove SDK
 * https://github.com/foxglove/foxglove-sdk
 */


#ifndef FOXGLOVE_H
#define FOXGLOVE_H

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#ifndef FOXGLOVE_NONNULL
#define FOXGLOVE_NONNULL
#endif


typedef struct foxglove_channel foxglove_channel;


/**
 * Allow clients to advertise channels to send data messages to the server.
 */
#define FOXGLOVE_SERVER_CAPABILITY_CLIENT_PUBLISH (1 << 0)

/**
 * Allow clients to subscribe and make connection graph updates
 */
#define FOXGLOVE_SERVER_CAPABILITY_CONNECTION_GRAPH (1 << 1)

/**
 * Allow clients to get & set parameters.
 */
#define FOXGLOVE_SERVER_CAPABILITY_PARAMETERS (1 << 2)

/**
 * Inform clients about the latest server time.
 *
 * This allows accelerated, slowed, or stepped control over the progress of time. If the
 * server publishes time data, then timestamps of published messages must originate from the
 * same time source.
 */
#define FOXGLOVE_SERVER_CAPABILITY_TIME (1 << 3)

/**
 * Allow clients to call services.
 */
#define FOXGLOVE_SERVER_CAPABILITY_SERVICES (1 << 4)

typedef struct foxglove_websocket_server foxglove_websocket_server;

typedef struct foxglove_client_channel {
  uint32_t id;
  const char *FOXGLOVE_NONNULL topic;
  const char *FOXGLOVE_NONNULL encoding;
  const char *FOXGLOVE_NONNULL schema_name;
  const char *schema_encoding;
  const void *schema;
  size_t schema_len;
} foxglove_client_channel;

typedef struct foxglove_server_callbacks {
  /**
   * A user-defined value that will be passed to callback functions
   */
  const void *context;
  void (*on_subscribe)(uint64_t channel_id, const void *context);
  void (*on_unsubscribe)(uint64_t channel_id, const void *context);
  void (*on_client_advertise)(uint32_t client_id,
                              const struct foxglove_client_channel *channel,
                              const void *context);
  void (*on_message_data)(uint32_t client_id,
                          uint32_t client_channel_id,
                          const uint8_t *payload,
                          size_t payload_len,
                          const void *context);
  void (*on_client_unadvertise)(uint32_t client_id, uint32_t client_channel_id, const void *context);
} foxglove_server_callbacks;

typedef uint8_t foxglove_server_capability;

typedef struct foxglove_server_options {
  const char *name;
  const char *host;
  uint16_t port;
  const struct foxglove_server_callbacks *callbacks;
  foxglove_server_capability capabilities;
  const char *const *supported_encodings;
  size_t supported_encodings_count;
} foxglove_server_options;

typedef struct foxglove_schema {
  const char *name;
  const char *encoding;
  const uint8_t *data;
  size_t data_len;
} foxglove_schema;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Create and start a server. The server must later be freed with `foxglove_server_free`.
 *
 * `port` may be 0, in which case an available port will be automatically selected.
 *
 * # Safety
 * `name` and `host` must be null-terminated strings with valid UTF8.
 */
struct foxglove_websocket_server *foxglove_server_start(const struct foxglove_server_options *FOXGLOVE_NONNULL options);

/**
 * Free a server created via `foxglove_server_start`.
 *
 * If the server has not already been stopped, it will be stopped automatically.
 */
void foxglove_server_free(struct foxglove_websocket_server *server);

/**
 * Get the port on which the server is listening.
 */
uint16_t foxglove_server_get_port(const struct foxglove_websocket_server *server);

/**
 * Stop and shut down a server.
 */
void foxglove_server_stop(struct foxglove_websocket_server *server);

/**
 * Create a new channel. The channel must later be freed with `foxglove_channel_free`.
 *
 * # Safety
 * `topic` and `message_encoding` must be null-terminated strings with valid UTF8. `schema` is an
 * optional pointer to a schema. The schema and the data it points to need only remain alive for
 * the duration of this function call (they will be copied).
 */
foxglove_channel *foxglove_channel_create(const char *topic,
                                          const char *message_encoding,
                                          const struct foxglove_schema *schema);

/**
 * Free a channel created via `foxglove_channel_create`.
 */
void foxglove_channel_free(foxglove_channel *channel);

uint64_t foxglove_channel_get_id(const foxglove_channel *channel);

/**
 * Log a message on a channel.
 *
 * # Safety
 * `data` must be non-null, and the range `[data, data + data_len)` must contain initialized data
 * contained within a single allocated object.
 *
 * `log_time`, `publish_time`, and `sequence` may be null, or may point to valid, properly-aligned values.
 */
void foxglove_channel_log(const foxglove_channel *channel,
                          const uint8_t *data,
                          size_t data_len,
                          const uint64_t *log_time,
                          const uint64_t *publish_time,
                          const uint32_t *sequence);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* FOXGLOVE_H */
