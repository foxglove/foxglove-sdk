// Generated by https://github.com/foxglove/foxglove-sdk

use std::ffi::{c_char, c_void};

use bytes::Bytes;

#[repr(u8)]
pub enum FoxgloveBuiltinSchema {
    CameraCalibration,
    CircleAnnotation,
    Color,
    CompressedImage,
    CompressedVideo,
    FrameTransform,
    FrameTransforms,
    GeoJSON,
    Grid,
    ImageAnnotations,
    KeyValuePair,
    LaserScan,
    LocationFix,
    Log,
    SceneEntityDeletion,
    SceneEntity,
    SceneUpdate,
    PackedElementField,
    Point2,
    Point3,
    PointCloud,
    PointsAnnotation,
    Pose,
    PoseInFrame,
    PosesInFrame,
    Quaternion,
    RawImage,
    TextAnnotation,
    Vector2,
    Vector3,
}

pub enum FoxgloveChannel {
    CameraCalibration(foxglove::Channel<foxglove::schemas::CameraCalibration>),
    CircleAnnotation(foxglove::Channel<foxglove::schemas::CircleAnnotation>),
    Color(foxglove::Channel<foxglove::schemas::Color>),
    CompressedImage(foxglove::Channel<foxglove::schemas::CompressedImage>),
    CompressedVideo(foxglove::Channel<foxglove::schemas::CompressedVideo>),
    FrameTransform(foxglove::Channel<foxglove::schemas::FrameTransform>),
    FrameTransforms(foxglove::Channel<foxglove::schemas::FrameTransforms>),
    GeoJSON(foxglove::Channel<foxglove::schemas::GeoJson>),
    Grid(foxglove::Channel<foxglove::schemas::Grid>),
    ImageAnnotations(foxglove::Channel<foxglove::schemas::ImageAnnotations>),
    KeyValuePair(foxglove::Channel<foxglove::schemas::KeyValuePair>),
    LaserScan(foxglove::Channel<foxglove::schemas::LaserScan>),
    LocationFix(foxglove::Channel<foxglove::schemas::LocationFix>),
    Log(foxglove::Channel<foxglove::schemas::Log>),
    SceneEntityDeletion(foxglove::Channel<foxglove::schemas::SceneEntityDeletion>),
    SceneEntity(foxglove::Channel<foxglove::schemas::SceneEntity>),
    SceneUpdate(foxglove::Channel<foxglove::schemas::SceneUpdate>),
    PackedElementField(foxglove::Channel<foxglove::schemas::PackedElementField>),
    Point2(foxglove::Channel<foxglove::schemas::Point2>),
    Point3(foxglove::Channel<foxglove::schemas::Point3>),
    PointCloud(foxglove::Channel<foxglove::schemas::PointCloud>),
    PointsAnnotation(foxglove::Channel<foxglove::schemas::PointsAnnotation>),
    Pose(foxglove::Channel<foxglove::schemas::Pose>),
    PoseInFrame(foxglove::Channel<foxglove::schemas::PoseInFrame>),
    PosesInFrame(foxglove::Channel<foxglove::schemas::PosesInFrame>),
    Quaternion(foxglove::Channel<foxglove::schemas::Quaternion>),
    RawImage(foxglove::Channel<foxglove::schemas::RawImage>),
    TextAnnotation(foxglove::Channel<foxglove::schemas::TextAnnotation>),
    Vector2(foxglove::Channel<foxglove::schemas::Vector2>),
    Vector3(foxglove::Channel<foxglove::schemas::Vector3>),
}

/// A timestamp, represented as an offset from a user-defined epoch.
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct Timestamp {
    /// Seconds since epoch.
    pub sec: u32,
    /// Additional nanoseconds since epoch.
    pub nsec: u32,
}

impl From<Timestamp> for foxglove::schemas::Timestamp {
    fn from(other: Timestamp) -> Self {
        Self::new(other.sec, other.nsec)
    }
}

/// A signed, fixed-length span of time.
///
/// The duration is represented by a count of seconds (which may be negative), and a count of
/// fractional seconds at nanosecond resolution (which are always positive).
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct Duration {
    /// Seconds offset.
    sec: i32,
    /// Nanoseconds offset in the positive direction.
    nsec: u32,
}

impl From<Duration> for foxglove::schemas::Duration {
    fn from(other: Duration) -> Self {
        Self::new(other.sec, other.nsec)
    }
}

/// Camera calibration parameters
#[repr(C)]
pub struct CameraCalibration {
    /// Timestamp of calibration data
    pub timestamp: Timestamp,

    /// Frame of reference for the camera. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
    pub frame_id: *const c_char,
    pub frame_id_len: usize,

    /// Image width
    pub width: u32,

    /// Image height
    pub height: u32,

    /// Name of distortion model
    ///
    /// Supported parameters: `plumb_bob` (k1, k2, p1, p2, k3) and `rational_polynomial` (k1, k2, p1, p2, k3, k4, k5, k6). Distortion models are based on [OpenCV's](https://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html) [pinhole camera model](https://en.wikipedia.org/wiki/Distortion_%28optics%29#Software_correction). This is the same [implementation used by ROS](http://docs.ros.org/en/diamondback/api/image_geometry/html/c++/pinhole__camera__model_8cpp_source.html)
    pub distortion_model: *const c_char,
    pub distortion_model_len: usize,

    /// Distortion parameters
    pub D: *const f64,
    pub D_count: usize,

    /// Intrinsic camera matrix (3x3 row-major matrix)
    ///
    /// A 3x3 row-major matrix for the raw (distorted) image.
    ///
    /// Projects 3D points in the camera coordinate frame to 2D pixel coordinates using the focal lengths (fx, fy) and principal point (cx, cy).
    ///
    /// ```
    ///     [fx  0 cx]
    /// K = [ 0 fy cy]
    ///     [ 0  0  1]
    /// ```
    ///
    pub K: [f64; 9],

    /// Rectification matrix (stereo cameras only, 3x3 row-major matrix)
    ///
    /// A rotation matrix aligning the camera coordinate system to the ideal stereo image plane so that epipolar lines in both stereo images are parallel.
    pub R: [f64; 9],

    /// Projection/camera matrix (3x4 row-major matrix)
    ///
    /// ```
    ///     [fx'  0  cx' Tx]
    /// P = [ 0  fy' cy' Ty]
    ///     [ 0   0   1   0]
    /// ```
    ///
    /// By convention, this matrix specifies the intrinsic (camera) matrix of the processed (rectified) image. That is, the left 3x3 portion is the normal camera intrinsic matrix for the rectified image.
    ///
    /// It projects 3D points in the camera coordinate frame to 2D pixel coordinates using the focal lengths (fx', fy') and principal point (cx', cy') - these may differ from the values in K.
    ///
    /// For monocular cameras, Tx = Ty = 0. Normally, monocular cameras will also have R = the identity and P[1:3,1:3] = K.
    ///
    /// For a stereo pair, the fourth column [Tx Ty 0]' is related to the position of the optical center of the second camera in the first camera's frame. We assume Tz = 0 so both cameras are in the same stereo image plane. The first camera always has Tx = Ty = 0. For the right (second) camera of a horizontal stereo pair, Ty = 0 and Tx = -fx' * B, where B is the baseline between the cameras.
    ///
    /// Given a 3D point [X Y Z]', the projection (x, y) of the point onto the rectified image is given by:
    ///
    /// ```
    /// [u v w]' = P * [X Y Z 1]'
    ///        x = u / w
    ///        y = v / w
    /// ```
    ///
    /// This holds for both images of a stereo pair.
    ///
    pub P: [f64; 12],
}

impl From<&CameraCalibration> for foxglove::schemas::CameraCalibration {
    fn from(msg: &CameraCalibration) -> Self {
        Self {
            timestamp: Some(msg.timestamp.into()),
            frame_id: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.frame_id as *const u8, msg.frame_id_len)
            })
            .unwrap()
            .to_string(),
            width: msg.width,
            height: msg.height,
            distortion_model: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(
                    msg.distortion_model as *const u8,
                    msg.distortion_model_len,
                )
            })
            .unwrap()
            .to_string(),
            d: todo!("arrays"),
            k: todo!("arrays"),
            r: todo!("arrays"),
            p: todo!("arrays"),
        }
    }
}

/// A circle annotation on a 2D image
#[repr(C)]
pub struct CircleAnnotation {
    /// Timestamp of circle
    pub timestamp: Timestamp,

    /// Center of the circle in 2D image coordinates (pixels).
    /// The coordinate uses the top-left corner of the top-left pixel of the image as the origin.
    pub position: *const Point2,

    /// Circle diameter in pixels
    pub diameter: f64,

    /// Line thickness in pixels
    pub thickness: f64,

    /// Fill color
    pub fill_color: *const Color,

    /// Outline color
    pub outline_color: *const Color,
}

impl From<&CircleAnnotation> for foxglove::schemas::CircleAnnotation {
    fn from(msg: &CircleAnnotation) -> Self {
        Self {
            timestamp: Some(msg.timestamp.into()),
            position: Some(unsafe { &*msg.position }.into()),
            diameter: msg.diameter,
            thickness: msg.thickness,
            fill_color: Some(unsafe { &*msg.fill_color }.into()),
            outline_color: Some(unsafe { &*msg.outline_color }.into()),
        }
    }
}

/// A color in RGBA format
#[repr(C)]
pub struct Color {
    /// Red value between 0 and 1
    pub r: f64,

    /// Green value between 0 and 1
    pub g: f64,

    /// Blue value between 0 and 1
    pub b: f64,

    /// Alpha value between 0 and 1
    pub a: f64,
}

impl From<&Color> for foxglove::schemas::Color {
    fn from(msg: &Color) -> Self {
        Self {
            r: msg.r,
            g: msg.g,
            b: msg.b,
            a: msg.a,
        }
    }
}

/// A compressed image
#[repr(C)]
pub struct CompressedImage {
    /// Timestamp of image
    pub timestamp: Timestamp,

    /// Frame of reference for the image. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
    pub frame_id: *const c_char,
    pub frame_id_len: usize,

    /// Compressed image data
    pub data: *const c_void,
    pub data_len: usize,

    /// Image format
    ///
    /// Supported values: image media types supported by Chrome, such as `webp`, `jpeg`, `png`
    pub format: *const c_char,
    pub format_len: usize,
}

impl From<&CompressedImage> for foxglove::schemas::CompressedImage {
    fn from(msg: &CompressedImage) -> Self {
        Self {
            timestamp: Some(msg.timestamp.into()),
            frame_id: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.frame_id as *const u8, msg.frame_id_len)
            })
            .unwrap()
            .to_string(),
            data: Bytes::copy_from_slice(unsafe {
                std::slice::from_raw_parts(msg.data, msg.data_len)
            }),
            format: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.format as *const u8, msg.format_len)
            })
            .unwrap()
            .to_string(),
        }
    }
}

/// A single frame of a compressed video bitstream
#[repr(C)]
pub struct CompressedVideo {
    /// Timestamp of video frame
    pub timestamp: Timestamp,

    /// Frame of reference for the video.
    ///
    /// The origin of the frame is the optical center of the camera. +x points to the right in the video, +y points down, and +z points into the plane of the video.
    pub frame_id: *const c_char,
    pub frame_id_len: usize,

    /// Compressed video frame data.
    ///
    /// For packet-based video codecs this data must begin and end on packet boundaries (no partial packets), and must contain enough video packets to decode exactly one image (either a keyframe or delta frame). Note: Foxglove does not support video streams that include B frames because they require lookahead.
    ///
    /// Specifically, the requirements for different `format` values are:
    ///
    /// - `h264`
    ///   - Use Annex B formatted data
    ///   - Each CompressedVideo message should contain enough NAL units to decode exactly one video frame
    ///   - Each message containing a key frame (IDR) must also include a SPS NAL unit
    ///
    /// - `h265` (HEVC)
    ///   - Use Annex B formatted data
    ///   - Each CompressedVideo message should contain enough NAL units to decode exactly one video frame
    ///   - Each message containing a key frame (IRAP) must also include relevant VPS/SPS/PPS NAL units
    ///
    /// - `vp9`
    ///   - Each CompressedVideo message should contain exactly one video frame
    ///
    /// - `av1`
    ///   - Use the "Low overhead bitstream format" (section 5.2)
    ///   - Each CompressedVideo message should contain enough OBUs to decode exactly one video frame
    ///   - Each message containing a key frame must also include a Sequence Header OBU
    pub data: *const c_void,
    pub data_len: usize,

    /// Video format.
    ///
    /// Supported values: `h264`, `h265`, `vp9`, `av1`.
    ///
    /// Note: compressed video support is subject to hardware limitations and patent licensing, so not all encodings may be supported on all platforms. See more about [H.265 support](https://caniuse.com/hevc), [VP9 support](https://caniuse.com/webm), and [AV1 support](https://caniuse.com/av1).
    pub format: *const c_char,
    pub format_len: usize,
}

impl From<&CompressedVideo> for foxglove::schemas::CompressedVideo {
    fn from(msg: &CompressedVideo) -> Self {
        Self {
            timestamp: Some(msg.timestamp.into()),
            frame_id: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.frame_id as *const u8, msg.frame_id_len)
            })
            .unwrap()
            .to_string(),
            data: Bytes::copy_from_slice(unsafe {
                std::slice::from_raw_parts(msg.data, msg.data_len)
            }),
            format: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.format as *const u8, msg.format_len)
            })
            .unwrap()
            .to_string(),
        }
    }
}

/// A transform between two reference frames in 3D space
#[repr(C)]
pub struct FrameTransform {
    /// Timestamp of transform
    pub timestamp: Timestamp,

    /// Name of the parent frame
    pub parent_frame_id: *const c_char,
    pub parent_frame_id_len: usize,

    /// Name of the child frame
    pub child_frame_id: *const c_char,
    pub child_frame_id_len: usize,

    /// Translation component of the transform
    pub translation: *const Vector3,

    /// Rotation component of the transform
    pub rotation: *const Quaternion,
}

impl From<&FrameTransform> for foxglove::schemas::FrameTransform {
    fn from(msg: &FrameTransform) -> Self {
        Self {
            timestamp: Some(msg.timestamp.into()),
            parent_frame_id: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(
                    msg.parent_frame_id as *const u8,
                    msg.parent_frame_id_len,
                )
            })
            .unwrap()
            .to_string(),
            child_frame_id: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.child_frame_id as *const u8, msg.child_frame_id_len)
            })
            .unwrap()
            .to_string(),
            translation: Some(unsafe { &*msg.translation }.into()),
            rotation: Some(unsafe { &*msg.rotation }.into()),
        }
    }
}

/// An array of FrameTransform messages
#[repr(C)]
pub struct FrameTransforms {
    /// Array of transforms
    pub transforms: *const *const FrameTransform,
    pub transforms_count: usize,
}

impl From<&FrameTransforms> for foxglove::schemas::FrameTransforms {
    fn from(msg: &FrameTransforms) -> Self {
        Self {
            transforms: todo!("arrays"),
        }
    }
}

/// GeoJSON data for annotating maps
#[repr(C)]
pub struct GeoJSON {
    /// GeoJSON data encoded as a UTF-8 string
    pub geojson: *const c_char,
    pub geojson_len: usize,
}

impl From<&GeoJSON> for foxglove::schemas::GeoJson {
    fn from(msg: &GeoJSON) -> Self {
        Self {
            geojson: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.geojson as *const u8, msg.geojson_len)
            })
            .unwrap()
            .to_string(),
        }
    }
}

/// A 2D grid of data
#[repr(C)]
pub struct Grid {
    /// Timestamp of grid
    pub timestamp: Timestamp,

    /// Frame of reference
    pub frame_id: *const c_char,
    pub frame_id_len: usize,

    /// Origin of grid's corner relative to frame of reference; grid is positioned in the x-y plane relative to this origin
    pub pose: *const Pose,

    /// Number of grid columns
    pub column_count: u32,

    /// Size of single grid cell along x and y axes, relative to `pose`
    pub cell_size: *const Vector2,

    /// Number of bytes between rows in `data`
    pub row_stride: u32,

    /// Number of bytes between cells within a row in `data`
    pub cell_stride: u32,

    /// Fields in `data`. `red`, `green`, `blue`, and `alpha` are optional for customizing the grid's color.
    pub fields: *const *const PackedElementField,
    pub fields_count: usize,

    /// Grid cell data, interpreted using `fields`, in row-major (y-major) order
    pub data: *const c_void,
    pub data_len: usize,
}

impl From<&Grid> for foxglove::schemas::Grid {
    fn from(msg: &Grid) -> Self {
        Self {
            timestamp: Some(msg.timestamp.into()),
            frame_id: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.frame_id as *const u8, msg.frame_id_len)
            })
            .unwrap()
            .to_string(),
            pose: Some(unsafe { &*msg.pose }.into()),
            column_count: msg.column_count,
            cell_size: Some(unsafe { &*msg.cell_size }.into()),
            row_stride: msg.row_stride,
            cell_stride: msg.cell_stride,
            fields: todo!("arrays"),
            data: Bytes::copy_from_slice(unsafe {
                std::slice::from_raw_parts(msg.data, msg.data_len)
            }),
        }
    }
}

/// Array of annotations for a 2D image
#[repr(C)]
pub struct ImageAnnotations {
    /// Circle annotations
    pub circles: *const *const CircleAnnotation,
    pub circles_count: usize,

    /// Points annotations
    pub points: *const *const PointsAnnotation,
    pub points_count: usize,

    /// Text annotations
    pub texts: *const *const TextAnnotation,
    pub texts_count: usize,
}

impl From<&ImageAnnotations> for foxglove::schemas::ImageAnnotations {
    fn from(msg: &ImageAnnotations) -> Self {
        Self {
            circles: todo!("arrays"),
            points: todo!("arrays"),
            texts: todo!("arrays"),
        }
    }
}

/// A key with its associated value
#[repr(C)]
pub struct KeyValuePair {
    /// Key
    pub key: *const c_char,
    pub key_len: usize,

    /// Value
    pub value: *const c_char,
    pub value_len: usize,
}

impl From<&KeyValuePair> for foxglove::schemas::KeyValuePair {
    fn from(msg: &KeyValuePair) -> Self {
        Self {
            key: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.key as *const u8, msg.key_len)
            })
            .unwrap()
            .to_string(),
            value: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.value as *const u8, msg.value_len)
            })
            .unwrap()
            .to_string(),
        }
    }
}

/// A single scan from a planar laser range-finder
#[repr(C)]
pub struct LaserScan {
    /// Timestamp of scan
    pub timestamp: Timestamp,

    /// Frame of reference
    pub frame_id: *const c_char,
    pub frame_id_len: usize,

    /// Origin of scan relative to frame of reference; points are positioned in the x-y plane relative to this origin; angles are interpreted as counterclockwise rotations around the z axis with 0 rad being in the +x direction
    pub pose: *const Pose,

    /// Bearing of first point, in radians
    pub start_angle: f64,

    /// Bearing of last point, in radians
    pub end_angle: f64,

    /// Distance of detections from origin; assumed to be at equally-spaced angles between `start_angle` and `end_angle`
    pub ranges: *const f64,
    pub ranges_count: usize,

    /// Intensity of detections
    pub intensities: *const f64,
    pub intensities_count: usize,
}

impl From<&LaserScan> for foxglove::schemas::LaserScan {
    fn from(msg: &LaserScan) -> Self {
        Self {
            timestamp: Some(msg.timestamp.into()),
            frame_id: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.frame_id as *const u8, msg.frame_id_len)
            })
            .unwrap()
            .to_string(),
            pose: Some(unsafe { &*msg.pose }.into()),
            start_angle: msg.start_angle,
            end_angle: msg.end_angle,
            ranges: todo!("arrays"),
            intensities: todo!("arrays"),
        }
    }
}

/// A navigation satellite fix for any Global Navigation Satellite System
#[repr(C)]
pub struct LocationFix {
    /// Timestamp of the message
    pub timestamp: Timestamp,

    /// Frame for the sensor. Latitude and longitude readings are at the origin of the frame.
    pub frame_id: *const c_char,
    pub frame_id_len: usize,

    /// Latitude in degrees
    pub latitude: f64,

    /// Longitude in degrees
    pub longitude: f64,

    /// Altitude in meters
    pub altitude: f64,

    /// Position covariance (m^2) defined relative to a tangential plane through the reported position. The components are East, North, and Up (ENU), in row-major order.
    pub position_covariance: [f64; 9],

    /// If `position_covariance` is available, `position_covariance_type` must be set to indicate the type of covariance.
    pub position_covariance_type: i32,
}

impl From<&LocationFix> for foxglove::schemas::LocationFix {
    fn from(msg: &LocationFix) -> Self {
        Self {
            timestamp: Some(msg.timestamp.into()),
            frame_id: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.frame_id as *const u8, msg.frame_id_len)
            })
            .unwrap()
            .to_string(),
            latitude: msg.latitude,
            longitude: msg.longitude,
            altitude: msg.altitude,
            position_covariance: todo!("arrays"),
            position_covariance_type: todo!(),
        }
    }
}

/// A log message
#[repr(C)]
pub struct Log {
    /// Timestamp of log message
    pub timestamp: Timestamp,

    /// Log level
    pub level: i32,

    /// Log message
    pub message: *const c_char,
    pub message_len: usize,

    /// Process or node name
    pub name: *const c_char,
    pub name_len: usize,

    /// Filename
    pub file: *const c_char,
    pub file_len: usize,

    /// Line number in the file
    pub line: u32,
}

impl From<&Log> for foxglove::schemas::Log {
    fn from(msg: &Log) -> Self {
        Self {
            timestamp: Some(msg.timestamp.into()),
            level: todo!(),
            message: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.message as *const u8, msg.message_len)
            })
            .unwrap()
            .to_string(),
            name: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.name as *const u8, msg.name_len)
            })
            .unwrap()
            .to_string(),
            file: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.file as *const u8, msg.file_len)
            })
            .unwrap()
            .to_string(),
            line: msg.line,
        }
    }
}

/// Command to remove previously published entities
#[repr(C)]
pub struct SceneEntityDeletion {
    /// Timestamp of the deletion. Only matching entities earlier than this timestamp will be deleted.
    pub timestamp: Timestamp,

    /// Type of deletion action to perform
    pub r#type: i32,

    /// Identifier which must match if `type` is `MATCHING_ID`.
    pub id: *const c_char,
    pub id_len: usize,
}

impl From<&SceneEntityDeletion> for foxglove::schemas::SceneEntityDeletion {
    fn from(msg: &SceneEntityDeletion) -> Self {
        Self {
            timestamp: Some(msg.timestamp.into()),
            r#type: todo!(),
            id: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.id as *const u8, msg.id_len)
            })
            .unwrap()
            .to_string(),
        }
    }
}

/// A visual element in a 3D scene. An entity may be composed of multiple primitives which all share the same frame of reference.
#[repr(C)]
pub struct SceneEntity {
    /// Timestamp of the entity
    pub timestamp: Timestamp,

    /// Frame of reference
    pub frame_id: *const c_char,
    pub frame_id_len: usize,

    /// Identifier for the entity. A entity will replace any prior entity on the same topic with the same `id`.
    pub id: *const c_char,
    pub id_len: usize,

    /// Length of time (relative to `timestamp`) after which the entity should be automatically removed. Zero value indicates the entity should remain visible until it is replaced or deleted.
    pub lifetime: Duration,

    /// Whether the entity should keep its location in the fixed frame (false) or follow the frame specified in `frame_id` as it moves relative to the fixed frame (true)
    pub frame_locked: bool,

    /// Additional user-provided metadata associated with the entity. Keys must be unique.
    pub metadata: *const *const KeyValuePair,
    pub metadata_count: usize,

    /// Arrow primitives
    pub arrows: *const *const ArrowPrimitive,
    pub arrows_count: usize,

    /// Cube primitives
    pub cubes: *const *const CubePrimitive,
    pub cubes_count: usize,

    /// Sphere primitives
    pub spheres: *const *const SpherePrimitive,
    pub spheres_count: usize,

    /// Cylinder primitives
    pub cylinders: *const *const CylinderPrimitive,
    pub cylinders_count: usize,

    /// Line primitives
    pub lines: *const *const LinePrimitive,
    pub lines_count: usize,

    /// Triangle list primitives
    pub triangles: *const *const TriangleListPrimitive,
    pub triangles_count: usize,

    /// Text primitives
    pub texts: *const *const TextPrimitive,
    pub texts_count: usize,

    /// Model primitives
    pub models: *const *const ModelPrimitive,
    pub models_count: usize,
}

impl From<&SceneEntity> for foxglove::schemas::SceneEntity {
    fn from(msg: &SceneEntity) -> Self {
        Self {
            timestamp: Some(msg.timestamp.into()),
            frame_id: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.frame_id as *const u8, msg.frame_id_len)
            })
            .unwrap()
            .to_string(),
            id: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.id as *const u8, msg.id_len)
            })
            .unwrap()
            .to_string(),
            lifetime: Some(msg.lifetime.into()),
            frame_locked: msg.frame_locked,
            metadata: todo!("arrays"),
            arrows: todo!("arrays"),
            cubes: todo!("arrays"),
            spheres: todo!("arrays"),
            cylinders: todo!("arrays"),
            lines: todo!("arrays"),
            triangles: todo!("arrays"),
            texts: todo!("arrays"),
            models: todo!("arrays"),
        }
    }
}

/// An update to the entities displayed in a 3D scene
#[repr(C)]
pub struct SceneUpdate {
    /// Scene entities to delete
    pub deletions: *const *const SceneEntityDeletion,
    pub deletions_count: usize,

    /// Scene entities to add or replace
    pub entities: *const *const SceneEntity,
    pub entities_count: usize,
}

impl From<&SceneUpdate> for foxglove::schemas::SceneUpdate {
    fn from(msg: &SceneUpdate) -> Self {
        Self {
            deletions: todo!("arrays"),
            entities: todo!("arrays"),
        }
    }
}

/// A field present within each element in a byte array of packed elements.
#[repr(C)]
pub struct PackedElementField {
    /// Name of the field
    pub name: *const c_char,
    pub name_len: usize,

    /// Byte offset from start of data buffer
    pub offset: u32,

    /// Type of data in the field. Integers are stored using little-endian byte order.
    pub r#type: i32,
}

impl From<&PackedElementField> for foxglove::schemas::PackedElementField {
    fn from(msg: &PackedElementField) -> Self {
        Self {
            name: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.name as *const u8, msg.name_len)
            })
            .unwrap()
            .to_string(),
            offset: msg.offset,
            r#type: todo!(),
        }
    }
}

/// A point representing a position in 2D space
#[repr(C)]
pub struct Point2 {
    /// x coordinate position
    pub x: f64,

    /// y coordinate position
    pub y: f64,
}

impl From<&Point2> for foxglove::schemas::Point2 {
    fn from(msg: &Point2) -> Self {
        Self { x: msg.x, y: msg.y }
    }
}

/// A point representing a position in 3D space
#[repr(C)]
pub struct Point3 {
    /// x coordinate position
    pub x: f64,

    /// y coordinate position
    pub y: f64,

    /// z coordinate position
    pub z: f64,
}

impl From<&Point3> for foxglove::schemas::Point3 {
    fn from(msg: &Point3) -> Self {
        Self {
            x: msg.x,
            y: msg.y,
            z: msg.z,
        }
    }
}

/// A collection of N-dimensional points, which may contain additional fields with information like normals, intensity, etc.
#[repr(C)]
pub struct PointCloud {
    /// Timestamp of point cloud
    pub timestamp: Timestamp,

    /// Frame of reference
    pub frame_id: *const c_char,
    pub frame_id_len: usize,

    /// The origin of the point cloud relative to the frame of reference
    pub pose: *const Pose,

    /// Number of bytes between points in the `data`
    pub point_stride: u32,

    /// Fields in `data`. At least 2 coordinate fields from `x`, `y`, and `z` are required for each point's position; `red`, `green`, `blue`, and `alpha` are optional for customizing each point's color.
    pub fields: *const *const PackedElementField,
    pub fields_count: usize,

    /// Point data, interpreted using `fields`
    pub data: *const c_void,
    pub data_len: usize,
}

impl From<&PointCloud> for foxglove::schemas::PointCloud {
    fn from(msg: &PointCloud) -> Self {
        Self {
            timestamp: Some(msg.timestamp.into()),
            frame_id: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.frame_id as *const u8, msg.frame_id_len)
            })
            .unwrap()
            .to_string(),
            pose: Some(unsafe { &*msg.pose }.into()),
            point_stride: msg.point_stride,
            fields: todo!("arrays"),
            data: Bytes::copy_from_slice(unsafe {
                std::slice::from_raw_parts(msg.data, msg.data_len)
            }),
        }
    }
}

/// An array of points on a 2D image
#[repr(C)]
pub struct PointsAnnotation {
    /// Timestamp of annotation
    pub timestamp: Timestamp,

    /// Type of points annotation to draw
    pub r#type: i32,

    /// Points in 2D image coordinates (pixels).
    /// These coordinates use the top-left corner of the top-left pixel of the image as the origin.
    pub points: *const *const Point2,
    pub points_count: usize,

    /// Outline color
    pub outline_color: *const Color,

    /// Per-point colors, if `type` is `POINTS`, or per-segment stroke colors, if `type` is `LINE_LIST`, `LINE_STRIP` or `LINE_LOOP`.
    pub outline_colors: *const *const Color,
    pub outline_colors_count: usize,

    /// Fill color
    pub fill_color: *const Color,

    /// Stroke thickness in pixels
    pub thickness: f64,
}

impl From<&PointsAnnotation> for foxglove::schemas::PointsAnnotation {
    fn from(msg: &PointsAnnotation) -> Self {
        Self {
            timestamp: Some(msg.timestamp.into()),
            r#type: todo!(),
            points: todo!("arrays"),
            outline_color: Some(unsafe { &*msg.outline_color }.into()),
            outline_colors: todo!("arrays"),
            fill_color: Some(unsafe { &*msg.fill_color }.into()),
            thickness: msg.thickness,
        }
    }
}

/// A position and orientation for an object or reference frame in 3D space
#[repr(C)]
pub struct Pose {
    /// Point denoting position in 3D space
    pub position: *const Vector3,

    /// Quaternion denoting orientation in 3D space
    pub orientation: *const Quaternion,
}

impl From<&Pose> for foxglove::schemas::Pose {
    fn from(msg: &Pose) -> Self {
        Self {
            position: Some(unsafe { &*msg.position }.into()),
            orientation: Some(unsafe { &*msg.orientation }.into()),
        }
    }
}

/// A timestamped pose for an object or reference frame in 3D space
#[repr(C)]
pub struct PoseInFrame {
    /// Timestamp of pose
    pub timestamp: Timestamp,

    /// Frame of reference for pose position and orientation
    pub frame_id: *const c_char,
    pub frame_id_len: usize,

    /// Pose in 3D space
    pub pose: *const Pose,
}

impl From<&PoseInFrame> for foxglove::schemas::PoseInFrame {
    fn from(msg: &PoseInFrame) -> Self {
        Self {
            timestamp: Some(msg.timestamp.into()),
            frame_id: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.frame_id as *const u8, msg.frame_id_len)
            })
            .unwrap()
            .to_string(),
            pose: Some(unsafe { &*msg.pose }.into()),
        }
    }
}

/// An array of timestamped poses for an object or reference frame in 3D space
#[repr(C)]
pub struct PosesInFrame {
    /// Timestamp of pose
    pub timestamp: Timestamp,

    /// Frame of reference for pose position and orientation
    pub frame_id: *const c_char,
    pub frame_id_len: usize,

    /// Poses in 3D space
    pub poses: *const *const Pose,
    pub poses_count: usize,
}

impl From<&PosesInFrame> for foxglove::schemas::PosesInFrame {
    fn from(msg: &PosesInFrame) -> Self {
        Self {
            timestamp: Some(msg.timestamp.into()),
            frame_id: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.frame_id as *const u8, msg.frame_id_len)
            })
            .unwrap()
            .to_string(),
            poses: todo!("arrays"),
        }
    }
}

/// A [quaternion](https://eater.net/quaternions) representing a rotation in 3D space
#[repr(C)]
pub struct Quaternion {
    /// x value
    pub x: f64,

    /// y value
    pub y: f64,

    /// z value
    pub z: f64,

    /// w value
    pub w: f64,
}

impl From<&Quaternion> for foxglove::schemas::Quaternion {
    fn from(msg: &Quaternion) -> Self {
        Self {
            x: msg.x,
            y: msg.y,
            z: msg.z,
            w: msg.w,
        }
    }
}

/// A raw image
#[repr(C)]
pub struct RawImage {
    /// Timestamp of image
    pub timestamp: Timestamp,

    /// Frame of reference for the image. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
    pub frame_id: *const c_char,
    pub frame_id_len: usize,

    /// Image width
    pub width: u32,

    /// Image height
    pub height: u32,

    /// Encoding of the raw image data
    ///
    /// Supported values: `8UC1`, `8UC3`, `16UC1` (little endian), `32FC1` (little endian), `bayer_bggr8`, `bayer_gbrg8`, `bayer_grbg8`, `bayer_rggb8`, `bgr8`, `bgra8`, `mono8`, `mono16`, `rgb8`, `rgba8`, `uyvy` or `yuv422`, `yuyv` or `yuv422_yuy2`
    pub encoding: *const c_char,
    pub encoding_len: usize,

    /// Byte length of a single row
    pub step: u32,

    /// Raw image data
    pub data: *const c_void,
    pub data_len: usize,
}

impl From<&RawImage> for foxglove::schemas::RawImage {
    fn from(msg: &RawImage) -> Self {
        Self {
            timestamp: Some(msg.timestamp.into()),
            frame_id: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.frame_id as *const u8, msg.frame_id_len)
            })
            .unwrap()
            .to_string(),
            width: msg.width,
            height: msg.height,
            encoding: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.encoding as *const u8, msg.encoding_len)
            })
            .unwrap()
            .to_string(),
            step: msg.step,
            data: Bytes::copy_from_slice(unsafe {
                std::slice::from_raw_parts(msg.data, msg.data_len)
            }),
        }
    }
}

/// A text label on a 2D image
#[repr(C)]
pub struct TextAnnotation {
    /// Timestamp of annotation
    pub timestamp: Timestamp,

    /// Bottom-left origin of the text label in 2D image coordinates (pixels).
    /// The coordinate uses the top-left corner of the top-left pixel of the image as the origin.
    pub position: *const Point2,

    /// Text to display
    pub text: *const c_char,
    pub text_len: usize,

    /// Font size in pixels
    pub font_size: f64,

    /// Text color
    pub text_color: *const Color,

    /// Background fill color
    pub background_color: *const Color,
}

impl From<&TextAnnotation> for foxglove::schemas::TextAnnotation {
    fn from(msg: &TextAnnotation) -> Self {
        Self {
            timestamp: Some(msg.timestamp.into()),
            position: Some(unsafe { &*msg.position }.into()),
            text: std::str::from_utf8(unsafe {
                std::slice::from_raw_parts(msg.text as *const u8, msg.text_len)
            })
            .unwrap()
            .to_string(),
            font_size: msg.font_size,
            text_color: Some(unsafe { &*msg.text_color }.into()),
            background_color: Some(unsafe { &*msg.background_color }.into()),
        }
    }
}

/// A vector in 2D space that represents a direction only
#[repr(C)]
pub struct Vector2 {
    /// x coordinate length
    pub x: f64,

    /// y coordinate length
    pub y: f64,
}

impl From<&Vector2> for foxglove::schemas::Vector2 {
    fn from(msg: &Vector2) -> Self {
        Self { x: msg.x, y: msg.y }
    }
}

/// A vector in 3D space that represents a direction only
#[repr(C)]
pub struct Vector3 {
    /// x coordinate length
    pub x: f64,

    /// y coordinate length
    pub y: f64,

    /// z coordinate length
    pub z: f64,
}

impl From<&Vector3> for foxglove::schemas::Vector3 {
    fn from(msg: &Vector3) -> Self {
        Self {
            x: msg.x,
            y: msg.y,
            z: msg.z,
        }
    }
}

impl FoxgloveChannel {
    pub fn id(&self) -> foxglove::ChannelId {
        match self {
            FoxgloveChannel::CameraCalibration(ch) => ch.id(),
            FoxgloveChannel::CircleAnnotation(ch) => ch.id(),
            FoxgloveChannel::Color(ch) => ch.id(),
            FoxgloveChannel::CompressedImage(ch) => ch.id(),
            FoxgloveChannel::CompressedVideo(ch) => ch.id(),
            FoxgloveChannel::FrameTransform(ch) => ch.id(),
            FoxgloveChannel::FrameTransforms(ch) => ch.id(),
            FoxgloveChannel::GeoJSON(ch) => ch.id(),
            FoxgloveChannel::Grid(ch) => ch.id(),
            FoxgloveChannel::ImageAnnotations(ch) => ch.id(),
            FoxgloveChannel::KeyValuePair(ch) => ch.id(),
            FoxgloveChannel::LaserScan(ch) => ch.id(),
            FoxgloveChannel::LocationFix(ch) => ch.id(),
            FoxgloveChannel::Log(ch) => ch.id(),
            FoxgloveChannel::SceneEntityDeletion(ch) => ch.id(),
            FoxgloveChannel::SceneEntity(ch) => ch.id(),
            FoxgloveChannel::SceneUpdate(ch) => ch.id(),
            FoxgloveChannel::PackedElementField(ch) => ch.id(),
            FoxgloveChannel::Point2(ch) => ch.id(),
            FoxgloveChannel::Point3(ch) => ch.id(),
            FoxgloveChannel::PointCloud(ch) => ch.id(),
            FoxgloveChannel::PointsAnnotation(ch) => ch.id(),
            FoxgloveChannel::Pose(ch) => ch.id(),
            FoxgloveChannel::PoseInFrame(ch) => ch.id(),
            FoxgloveChannel::PosesInFrame(ch) => ch.id(),
            FoxgloveChannel::Quaternion(ch) => ch.id(),
            FoxgloveChannel::RawImage(ch) => ch.id(),
            FoxgloveChannel::TextAnnotation(ch) => ch.id(),
            FoxgloveChannel::Vector2(ch) => ch.id(),
            FoxgloveChannel::Vector3(ch) => ch.id(),
        }
    }

    /// # Safety
    /// `msg` must be a valid pointer to the same message schema this channel was created with.
    pub unsafe fn log_with_meta(
        &self,
        msg: *const core::ffi::c_void,
        meta: foxglove::PartialMetadata,
    ) {
        match self {
            FoxgloveChannel::CameraCalibration(ch) => {
                let msg = unsafe { &*(msg as *const self::CameraCalibration) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::CircleAnnotation(ch) => {
                let msg = unsafe { &*(msg as *const self::CircleAnnotation) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::Color(ch) => {
                let msg = unsafe { &*(msg as *const self::Color) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::CompressedImage(ch) => {
                let msg = unsafe { &*(msg as *const self::CompressedImage) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::CompressedVideo(ch) => {
                let msg = unsafe { &*(msg as *const self::CompressedVideo) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::FrameTransform(ch) => {
                let msg = unsafe { &*(msg as *const self::FrameTransform) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::FrameTransforms(ch) => {
                let msg = unsafe { &*(msg as *const self::FrameTransforms) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::GeoJSON(ch) => {
                let msg = unsafe { &*(msg as *const self::GeoJSON) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::Grid(ch) => {
                let msg = unsafe { &*(msg as *const self::Grid) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::ImageAnnotations(ch) => {
                let msg = unsafe { &*(msg as *const self::ImageAnnotations) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::KeyValuePair(ch) => {
                let msg = unsafe { &*(msg as *const self::KeyValuePair) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::LaserScan(ch) => {
                let msg = unsafe { &*(msg as *const self::LaserScan) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::LocationFix(ch) => {
                let msg = unsafe { &*(msg as *const self::LocationFix) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::Log(ch) => {
                let msg = unsafe { &*(msg as *const self::Log) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::SceneEntityDeletion(ch) => {
                let msg = unsafe { &*(msg as *const self::SceneEntityDeletion) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::SceneEntity(ch) => {
                let msg = unsafe { &*(msg as *const self::SceneEntity) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::SceneUpdate(ch) => {
                let msg = unsafe { &*(msg as *const self::SceneUpdate) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::PackedElementField(ch) => {
                let msg = unsafe { &*(msg as *const self::PackedElementField) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::Point2(ch) => {
                let msg = unsafe { &*(msg as *const self::Point2) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::Point3(ch) => {
                let msg = unsafe { &*(msg as *const self::Point3) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::PointCloud(ch) => {
                let msg = unsafe { &*(msg as *const self::PointCloud) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::PointsAnnotation(ch) => {
                let msg = unsafe { &*(msg as *const self::PointsAnnotation) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::Pose(ch) => {
                let msg = unsafe { &*(msg as *const self::Pose) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::PoseInFrame(ch) => {
                let msg = unsafe { &*(msg as *const self::PoseInFrame) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::PosesInFrame(ch) => {
                let msg = unsafe { &*(msg as *const self::PosesInFrame) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::Quaternion(ch) => {
                let msg = unsafe { &*(msg as *const self::Quaternion) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::RawImage(ch) => {
                let msg = unsafe { &*(msg as *const self::RawImage) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::TextAnnotation(ch) => {
                let msg = unsafe { &*(msg as *const self::TextAnnotation) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::Vector2(ch) => {
                let msg = unsafe { &*(msg as *const self::Vector2) };
                ch.log_with_meta(&msg.into(), meta)
            }
            FoxgloveChannel::Vector3(ch) => {
                let msg = unsafe { &*(msg as *const self::Vector3) };
                ch.log_with_meta(&msg.into(), meta)
            }
        }
    }
}

/// Build a strongly-typed Channel and turn it into a type-erased FoxgloveChannel.
pub(crate) fn build_channel_with_schema(
    builder: foxglove::ChannelBuilder,
    schema: FoxgloveBuiltinSchema,
) -> Result<FoxgloveChannel, foxglove::FoxgloveError> {
    match schema {
        FoxgloveBuiltinSchema::CameraCalibration => {
            builder.build().map(FoxgloveChannel::CameraCalibration)
        }
        FoxgloveBuiltinSchema::CircleAnnotation => {
            builder.build().map(FoxgloveChannel::CircleAnnotation)
        }
        FoxgloveBuiltinSchema::Color => builder.build().map(FoxgloveChannel::Color),
        FoxgloveBuiltinSchema::CompressedImage => {
            builder.build().map(FoxgloveChannel::CompressedImage)
        }
        FoxgloveBuiltinSchema::CompressedVideo => {
            builder.build().map(FoxgloveChannel::CompressedVideo)
        }
        FoxgloveBuiltinSchema::FrameTransform => {
            builder.build().map(FoxgloveChannel::FrameTransform)
        }
        FoxgloveBuiltinSchema::FrameTransforms => {
            builder.build().map(FoxgloveChannel::FrameTransforms)
        }
        FoxgloveBuiltinSchema::GeoJSON => builder.build().map(FoxgloveChannel::GeoJSON),
        FoxgloveBuiltinSchema::Grid => builder.build().map(FoxgloveChannel::Grid),
        FoxgloveBuiltinSchema::ImageAnnotations => {
            builder.build().map(FoxgloveChannel::ImageAnnotations)
        }
        FoxgloveBuiltinSchema::KeyValuePair => builder.build().map(FoxgloveChannel::KeyValuePair),
        FoxgloveBuiltinSchema::LaserScan => builder.build().map(FoxgloveChannel::LaserScan),
        FoxgloveBuiltinSchema::LocationFix => builder.build().map(FoxgloveChannel::LocationFix),
        FoxgloveBuiltinSchema::Log => builder.build().map(FoxgloveChannel::Log),
        FoxgloveBuiltinSchema::SceneEntityDeletion => {
            builder.build().map(FoxgloveChannel::SceneEntityDeletion)
        }
        FoxgloveBuiltinSchema::SceneEntity => builder.build().map(FoxgloveChannel::SceneEntity),
        FoxgloveBuiltinSchema::SceneUpdate => builder.build().map(FoxgloveChannel::SceneUpdate),
        FoxgloveBuiltinSchema::PackedElementField => {
            builder.build().map(FoxgloveChannel::PackedElementField)
        }
        FoxgloveBuiltinSchema::Point2 => builder.build().map(FoxgloveChannel::Point2),
        FoxgloveBuiltinSchema::Point3 => builder.build().map(FoxgloveChannel::Point3),
        FoxgloveBuiltinSchema::PointCloud => builder.build().map(FoxgloveChannel::PointCloud),
        FoxgloveBuiltinSchema::PointsAnnotation => {
            builder.build().map(FoxgloveChannel::PointsAnnotation)
        }
        FoxgloveBuiltinSchema::Pose => builder.build().map(FoxgloveChannel::Pose),
        FoxgloveBuiltinSchema::PoseInFrame => builder.build().map(FoxgloveChannel::PoseInFrame),
        FoxgloveBuiltinSchema::PosesInFrame => builder.build().map(FoxgloveChannel::PosesInFrame),
        FoxgloveBuiltinSchema::Quaternion => builder.build().map(FoxgloveChannel::Quaternion),
        FoxgloveBuiltinSchema::RawImage => builder.build().map(FoxgloveChannel::RawImage),
        FoxgloveBuiltinSchema::TextAnnotation => {
            builder.build().map(FoxgloveChannel::TextAnnotation)
        }
        FoxgloveBuiltinSchema::Vector2 => builder.build().map(FoxgloveChannel::Vector2),
        FoxgloveBuiltinSchema::Vector3 => builder.build().map(FoxgloveChannel::Vector3),
    }
}
