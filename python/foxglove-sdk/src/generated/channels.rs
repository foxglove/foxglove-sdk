//! Typed channels for logging Foxglove schemas
//! Generated by https://github.com/foxglove/foxglove-sdk

use super::messages;
use crate::{PyContext, PySchema};
use foxglove::{Channel, ChannelBuilder, PartialMetadata, SinkId};
use pyo3::prelude::*;
use pyo3::types::PyDict;
use std::collections::BTreeMap;
use std::num::NonZero;

pub fn register_submodule(parent_module: &Bound<'_, PyModule>) -> PyResult<()> {
    let module = PyModule::new(parent_module.py(), "channels")?;

    module.add_class::<ArrowPrimitiveChannel>()?;
    module.add_class::<CameraCalibrationChannel>()?;
    module.add_class::<CircleAnnotationChannel>()?;
    module.add_class::<ColorChannel>()?;
    module.add_class::<CompressedImageChannel>()?;
    module.add_class::<CompressedVideoChannel>()?;
    module.add_class::<CylinderPrimitiveChannel>()?;
    module.add_class::<CubePrimitiveChannel>()?;
    module.add_class::<FrameTransformChannel>()?;
    module.add_class::<FrameTransformsChannel>()?;
    module.add_class::<GeoJsonChannel>()?;
    module.add_class::<GridChannel>()?;
    module.add_class::<VoxelGridChannel>()?;
    module.add_class::<ImageAnnotationsChannel>()?;
    module.add_class::<KeyValuePairChannel>()?;
    module.add_class::<LaserScanChannel>()?;
    module.add_class::<LinePrimitiveChannel>()?;
    module.add_class::<LocationFixChannel>()?;
    module.add_class::<LocationFixesChannel>()?;
    module.add_class::<LogChannel>()?;
    module.add_class::<SceneEntityDeletionChannel>()?;
    module.add_class::<SceneEntityChannel>()?;
    module.add_class::<SceneUpdateChannel>()?;
    module.add_class::<ModelPrimitiveChannel>()?;
    module.add_class::<PackedElementFieldChannel>()?;
    module.add_class::<Point2Channel>()?;
    module.add_class::<Point3Channel>()?;
    module.add_class::<Point3InFrameChannel>()?;
    module.add_class::<PointCloudChannel>()?;
    module.add_class::<PointsAnnotationChannel>()?;
    module.add_class::<PoseChannel>()?;
    module.add_class::<PoseInFrameChannel>()?;
    module.add_class::<PosesInFrameChannel>()?;
    module.add_class::<QuaternionChannel>()?;
    module.add_class::<RawAudioChannel>()?;
    module.add_class::<RawImageChannel>()?;
    module.add_class::<SpherePrimitiveChannel>()?;
    module.add_class::<TextAnnotationChannel>()?;
    module.add_class::<TextPrimitiveChannel>()?;
    module.add_class::<TriangleListPrimitiveChannel>()?;
    module.add_class::<Vector2Channel>()?;
    module.add_class::<Vector3Channel>()?;

    // Define as a package
    // https://github.com/PyO3/pyo3/issues/759
    let py = parent_module.py();
    py.import("sys")?
        .getattr("modules")?
        .set_item("foxglove._foxglove_py.channels", &module)?;

    parent_module.add_submodule(&module)
}

/// A channel for logging :py:class:`foxglove.messages.ArrowPrimitive` messages.
#[pyclass(module = "foxglove.channels")]
struct ArrowPrimitiveChannel(Channel<foxglove::messages::ArrowPrimitive>);

#[pymethods]
impl ArrowPrimitiveChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.ArrowPrimitive` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::ArrowPrimitive, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "ArrowPrimitiveChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.CameraCalibration` messages.
#[pyclass(module = "foxglove.channels")]
struct CameraCalibrationChannel(Channel<foxglove::messages::CameraCalibration>);

#[pymethods]
impl CameraCalibrationChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.CameraCalibration` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::CameraCalibration, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "CameraCalibrationChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.CircleAnnotation` messages.
#[pyclass(module = "foxglove.channels")]
struct CircleAnnotationChannel(Channel<foxglove::messages::CircleAnnotation>);

#[pymethods]
impl CircleAnnotationChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.CircleAnnotation` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::CircleAnnotation, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "CircleAnnotationChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.Color` messages.
#[pyclass(module = "foxglove.channels")]
struct ColorChannel(Channel<foxglove::messages::Color>);

#[pymethods]
impl ColorChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.Color` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::Color, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!("ColorChannel(id={}, topic='{}')", self.id(), self.topic()).to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.CompressedImage` messages.
#[pyclass(module = "foxglove.channels")]
struct CompressedImageChannel(Channel<foxglove::messages::CompressedImage>);

#[pymethods]
impl CompressedImageChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.CompressedImage` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::CompressedImage, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "CompressedImageChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.CompressedVideo` messages.
#[pyclass(module = "foxglove.channels")]
struct CompressedVideoChannel(Channel<foxglove::messages::CompressedVideo>);

#[pymethods]
impl CompressedVideoChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.CompressedVideo` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::CompressedVideo, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "CompressedVideoChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.CylinderPrimitive` messages.
#[pyclass(module = "foxglove.channels")]
struct CylinderPrimitiveChannel(Channel<foxglove::messages::CylinderPrimitive>);

#[pymethods]
impl CylinderPrimitiveChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.CylinderPrimitive` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::CylinderPrimitive, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "CylinderPrimitiveChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.CubePrimitive` messages.
#[pyclass(module = "foxglove.channels")]
struct CubePrimitiveChannel(Channel<foxglove::messages::CubePrimitive>);

#[pymethods]
impl CubePrimitiveChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.CubePrimitive` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::CubePrimitive, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "CubePrimitiveChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.FrameTransform` messages.
#[pyclass(module = "foxglove.channels")]
struct FrameTransformChannel(Channel<foxglove::messages::FrameTransform>);

#[pymethods]
impl FrameTransformChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.FrameTransform` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::FrameTransform, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "FrameTransformChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.FrameTransforms` messages.
#[pyclass(module = "foxglove.channels")]
struct FrameTransformsChannel(Channel<foxglove::messages::FrameTransforms>);

#[pymethods]
impl FrameTransformsChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.FrameTransforms` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::FrameTransforms, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "FrameTransformsChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.GeoJson` messages.
#[pyclass(module = "foxglove.channels")]
struct GeoJsonChannel(Channel<foxglove::messages::GeoJson>);

#[pymethods]
impl GeoJsonChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.GeoJson` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::GeoJson, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!("GeoJsonChannel(id={}, topic='{}')", self.id(), self.topic()).to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.Grid` messages.
#[pyclass(module = "foxglove.channels")]
struct GridChannel(Channel<foxglove::messages::Grid>);

#[pymethods]
impl GridChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.Grid` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::Grid, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!("GridChannel(id={}, topic='{}')", self.id(), self.topic()).to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.VoxelGrid` messages.
#[pyclass(module = "foxglove.channels")]
struct VoxelGridChannel(Channel<foxglove::messages::VoxelGrid>);

#[pymethods]
impl VoxelGridChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.VoxelGrid` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::VoxelGrid, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "VoxelGridChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.ImageAnnotations` messages.
#[pyclass(module = "foxglove.channels")]
struct ImageAnnotationsChannel(Channel<foxglove::messages::ImageAnnotations>);

#[pymethods]
impl ImageAnnotationsChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.ImageAnnotations` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::ImageAnnotations, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "ImageAnnotationsChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.KeyValuePair` messages.
#[pyclass(module = "foxglove.channels")]
struct KeyValuePairChannel(Channel<foxglove::messages::KeyValuePair>);

#[pymethods]
impl KeyValuePairChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.KeyValuePair` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::KeyValuePair, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "KeyValuePairChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.LaserScan` messages.
#[pyclass(module = "foxglove.channels")]
struct LaserScanChannel(Channel<foxglove::messages::LaserScan>);

#[pymethods]
impl LaserScanChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.LaserScan` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::LaserScan, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "LaserScanChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.LinePrimitive` messages.
#[pyclass(module = "foxglove.channels")]
struct LinePrimitiveChannel(Channel<foxglove::messages::LinePrimitive>);

#[pymethods]
impl LinePrimitiveChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.LinePrimitive` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::LinePrimitive, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "LinePrimitiveChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.LocationFix` messages.
#[pyclass(module = "foxglove.channels")]
struct LocationFixChannel(Channel<foxglove::messages::LocationFix>);

#[pymethods]
impl LocationFixChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.LocationFix` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::LocationFix, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "LocationFixChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.LocationFixes` messages.
#[pyclass(module = "foxglove.channels")]
struct LocationFixesChannel(Channel<foxglove::messages::LocationFixes>);

#[pymethods]
impl LocationFixesChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.LocationFixes` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::LocationFixes, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "LocationFixesChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.Log` messages.
#[pyclass(module = "foxglove.channels")]
struct LogChannel(Channel<foxglove::messages::Log>);

#[pymethods]
impl LogChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.Log` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::Log, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!("LogChannel(id={}, topic='{}')", self.id(), self.topic()).to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.SceneEntityDeletion` messages.
#[pyclass(module = "foxglove.channels")]
struct SceneEntityDeletionChannel(Channel<foxglove::messages::SceneEntityDeletion>);

#[pymethods]
impl SceneEntityDeletionChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.SceneEntityDeletion` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::SceneEntityDeletion, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "SceneEntityDeletionChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.SceneEntity` messages.
#[pyclass(module = "foxglove.channels")]
struct SceneEntityChannel(Channel<foxglove::messages::SceneEntity>);

#[pymethods]
impl SceneEntityChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.SceneEntity` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::SceneEntity, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "SceneEntityChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.SceneUpdate` messages.
#[pyclass(module = "foxglove.channels")]
struct SceneUpdateChannel(Channel<foxglove::messages::SceneUpdate>);

#[pymethods]
impl SceneUpdateChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.SceneUpdate` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::SceneUpdate, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "SceneUpdateChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.ModelPrimitive` messages.
#[pyclass(module = "foxglove.channels")]
struct ModelPrimitiveChannel(Channel<foxglove::messages::ModelPrimitive>);

#[pymethods]
impl ModelPrimitiveChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.ModelPrimitive` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::ModelPrimitive, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "ModelPrimitiveChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.PackedElementField` messages.
#[pyclass(module = "foxglove.channels")]
struct PackedElementFieldChannel(Channel<foxglove::messages::PackedElementField>);

#[pymethods]
impl PackedElementFieldChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.PackedElementField` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::PackedElementField, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "PackedElementFieldChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.Point2` messages.
#[pyclass(module = "foxglove.channels")]
struct Point2Channel(Channel<foxglove::messages::Point2>);

#[pymethods]
impl Point2Channel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.Point2` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::Point2, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!("Point2Channel(id={}, topic='{}')", self.id(), self.topic()).to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.Point3` messages.
#[pyclass(module = "foxglove.channels")]
struct Point3Channel(Channel<foxglove::messages::Point3>);

#[pymethods]
impl Point3Channel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.Point3` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::Point3, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!("Point3Channel(id={}, topic='{}')", self.id(), self.topic()).to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.Point3InFrame` messages.
#[pyclass(module = "foxglove.channels")]
struct Point3InFrameChannel(Channel<foxglove::messages::Point3InFrame>);

#[pymethods]
impl Point3InFrameChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.Point3InFrame` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::Point3InFrame, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "Point3InFrameChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.PointCloud` messages.
#[pyclass(module = "foxglove.channels")]
struct PointCloudChannel(Channel<foxglove::messages::PointCloud>);

#[pymethods]
impl PointCloudChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.PointCloud` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::PointCloud, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "PointCloudChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.PointsAnnotation` messages.
#[pyclass(module = "foxglove.channels")]
struct PointsAnnotationChannel(Channel<foxglove::messages::PointsAnnotation>);

#[pymethods]
impl PointsAnnotationChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.PointsAnnotation` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::PointsAnnotation, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "PointsAnnotationChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.Pose` messages.
#[pyclass(module = "foxglove.channels")]
struct PoseChannel(Channel<foxglove::messages::Pose>);

#[pymethods]
impl PoseChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.Pose` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::Pose, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!("PoseChannel(id={}, topic='{}')", self.id(), self.topic()).to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.PoseInFrame` messages.
#[pyclass(module = "foxglove.channels")]
struct PoseInFrameChannel(Channel<foxglove::messages::PoseInFrame>);

#[pymethods]
impl PoseInFrameChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.PoseInFrame` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::PoseInFrame, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "PoseInFrameChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.PosesInFrame` messages.
#[pyclass(module = "foxglove.channels")]
struct PosesInFrameChannel(Channel<foxglove::messages::PosesInFrame>);

#[pymethods]
impl PosesInFrameChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.PosesInFrame` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::PosesInFrame, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "PosesInFrameChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.Quaternion` messages.
#[pyclass(module = "foxglove.channels")]
struct QuaternionChannel(Channel<foxglove::messages::Quaternion>);

#[pymethods]
impl QuaternionChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.Quaternion` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::Quaternion, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "QuaternionChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.RawAudio` messages.
#[pyclass(module = "foxglove.channels")]
struct RawAudioChannel(Channel<foxglove::messages::RawAudio>);

#[pymethods]
impl RawAudioChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.RawAudio` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::RawAudio, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "RawAudioChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.RawImage` messages.
#[pyclass(module = "foxglove.channels")]
struct RawImageChannel(Channel<foxglove::messages::RawImage>);

#[pymethods]
impl RawImageChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.RawImage` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::RawImage, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "RawImageChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.SpherePrimitive` messages.
#[pyclass(module = "foxglove.channels")]
struct SpherePrimitiveChannel(Channel<foxglove::messages::SpherePrimitive>);

#[pymethods]
impl SpherePrimitiveChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.SpherePrimitive` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::SpherePrimitive, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "SpherePrimitiveChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.TextAnnotation` messages.
#[pyclass(module = "foxglove.channels")]
struct TextAnnotationChannel(Channel<foxglove::messages::TextAnnotation>);

#[pymethods]
impl TextAnnotationChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.TextAnnotation` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::TextAnnotation, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "TextAnnotationChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.TextPrimitive` messages.
#[pyclass(module = "foxglove.channels")]
struct TextPrimitiveChannel(Channel<foxglove::messages::TextPrimitive>);

#[pymethods]
impl TextPrimitiveChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.TextPrimitive` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::TextPrimitive, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "TextPrimitiveChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.TriangleListPrimitive` messages.
#[pyclass(module = "foxglove.channels")]
struct TriangleListPrimitiveChannel(Channel<foxglove::messages::TriangleListPrimitive>);

#[pymethods]
impl TriangleListPrimitiveChannel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.TriangleListPrimitive` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(
        &self,
        msg: &schemas::TriangleListPrimitive,
        log_time: Option<u64>,
        sink_id: Option<u64>,
    ) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!(
            "TriangleListPrimitiveChannel(id={}, topic='{}')",
            self.id(),
            self.topic()
        )
        .to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.Vector2` messages.
#[pyclass(module = "foxglove.channels")]
struct Vector2Channel(Channel<foxglove::messages::Vector2>);

#[pymethods]
impl Vector2Channel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.Vector2` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::Vector2, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!("Vector2Channel(id={}, topic='{}')", self.id(), self.topic()).to_string()
    }
}

/// A channel for logging :py:class:`foxglove.messages.Vector3` messages.
#[pyclass(module = "foxglove.channels")]
struct Vector3Channel(Channel<foxglove::messages::Vector3>);

#[pymethods]
impl Vector3Channel {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(
        topic: &str,
        metadata: Option<BTreeMap<String, String>>,
        context: Option<&PyContext>,
    ) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:`foxglove.websocket.WebSocketServer`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:`foxglove.messages.Vector3` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(&self, msg: &schemas::Vector3, log_time: Option<u64>, sink_id: Option<u64>) {
        let metadata = PartialMetadata { log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!("Vector3Channel(id={}, topic='{}')", self.id(), self.topic()).to_string()
    }
}
