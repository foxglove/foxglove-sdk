# This file is autogenerated. Do not modify.
# Version: 0.3.0

from __future__ import annotations

import json
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Any, Literal


class _BaseModel(ABC):
    @abstractmethod
    def _to_dict(self) -> dict[str, Any]: ...

    def to_json(self) -> str:
        return json.dumps(
            self,
            allow_nan=False,
            separators=(",", ":"),
            default=_BaseModel._to_json_default,
        )

    @staticmethod
    def _to_json_default(obj: Any) -> Any:
        if isinstance(obj, _BaseModel):
            return {k: v for (k, v) in obj._to_dict().items() if v is not None}
        raise TypeError(f"{type(obj).__name__} is not JSON serializable")


class BasePanel(_BaseModel):
    """
    Abstract base class for all panels. This class cannot be instantiated directly. Use one of the provided subclasses instead, or Panel for a custom panel.
    """


VariableValue = bool | float | str | list["VariableValue"] | dict[str, "VariableValue"]

Variables = dict[str, VariableValue]


@dataclass(kw_only=True)
class UserScript(_BaseModel):
    name: str
    """
    The name of the user script.
    """

    source_code: str
    """
    The source code of the user script.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "name": self.name,
            "sourceCode": self.source_code,
        }


UserScripts = dict[str, UserScript]


@dataclass(kw_only=True)
class Tab(_BaseModel):
    """
    A tab in a tabs container.
    """

    title: str
    """
    The title of the tab.
    """

    content: Content

    def _to_dict(self) -> dict[str, Any]:
        return {
            "title": self.title,
            "content": self.content,
        }


@dataclass(kw_only=True)
class Tabs(_BaseModel):
    """
    A container for quickly switching between different groups of panels using a tab bar.
    """

    selected_tab_index: int | None = None
    """
    The 0-based index of the tab that is selected. Defaults to 0.
    """

    tabs: list[Tab]
    """
    The tabs to display in the container.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "tabs",
            "selectedTabIndex": self.selected_tab_index,
            "tabs": self.tabs,
        }


@dataclass(kw_only=True)
class StackItem(_BaseModel):
    """
    An item in the stack, includes the panel and the height of the item.
    """

    panel: BasePanel

    size: float
    """
    Size is a number greater than 0 that represents a proportion of the height of the stack container; e.g., 0.5 is 50% of the height of the stack container, and 1 is 100% of the height of it.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "panel": self.panel,
            "size": self.size,
        }


@dataclass(kw_only=True)
class Stack(_BaseModel):
    """
    A container for a vertically-scrollable stack of panels.
    """

    panels: list[StackItem]
    """
    The panels to display in the stack.
    """

    title: str | None = None
    """
    The title of the stack.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "stack",
            "panels": self.panels,
            "title": self.title,
        }


@dataclass(kw_only=True)
class SplitItem(_BaseModel):
    """
    An item in a layout with a ratio for space allocation.

    The ratio determines the proportion of space this item takes up. The direction of the Split container determines whether the ratio applies to width (horizontal) or height (vertical).
    For example, if a split has 3 items with ratios 1, 2, and 3, the first item takes 1/6 of the space,
    the second item takes 2/6, and the third item takes 3/6.
    """

    ratio: float
    """
    Proportion of space this item occupies relative to other items in the split. The actual space allocated is calculated by dividing this item's ratio by the sum of all ratios in the split. The ratio must be greater than 0.
    """

    content: Content

    def _to_dict(self) -> dict[str, Any]:
        return {
            "ratio": self.ratio,
            "content": self.content,
        }


@dataclass(kw_only=True)
class Split(_BaseModel):
    """
    A sequence of items displayed in a vertical or horizontal direction. Items are placed one next to the other (or one above the other for vertical direction), with space allocated according to their ratios.
    """

    direction: Literal["vertical", "horizontal"]
    """
    The direction in which items are displayed in the list. Defaults to horizontal.
    """

    items: list[SplitItem]
    """
    The items to display in the split container.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "split",
            "direction": self.direction,
            "items": self.items,
        }


Content = BasePanel | Tabs | Stack | Split


@dataclass(kw_only=True)
class MarkdownConfig(_BaseModel):
    font_size: float | None = None
    """
    Sets the base font size for the Markdown renderer.
    """

    markdown: str | None = None
    """
    The markdown content to display.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "fontSize": self.font_size,
            "markdown": self.markdown,
        }


@dataclass(kw_only=True)
class MarkdownPanel(BasePanel):
    """
    Write documentation and notes formatted using Markdown.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/markdown).
    """

    config: MarkdownConfig = field(default_factory=MarkdownConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Markdown",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


PanelConfig = dict[str, Any]


@dataclass(kw_only=True)
class Panel(BasePanel):
    """
    A schema for a generic panel; can be used as a fallback for panels that are not yet supported.
    """

    panel_type: str
    """
    A unique identifier for the panel type.
    """

    config: PanelConfig | None = None

    title: str | None = None
    """
    The title of the panel.
    """

    version: int
    """
    The version of the panel config schema.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": self.panel_type,
            "config": self.config,
            "title": self.title,
            "version": self.version,
        }


@dataclass(kw_only=True)
class StateTransitionsBaseCustomState(_BaseModel):
    """
    Display options for a discrete or continuous custom state
    """

    label: str | None = None

    color: str | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "label": self.label,
            "color": self.color,
        }


StateTransitionsRangeCustomStateOperator = Literal["=", "<", "<=", ">", ">="]


@dataclass(kw_only=True)
class StateTransitionsRangeCustomState(StateTransitionsBaseCustomState):
    """
    A range custom state for the customization strategy
    """

    value: float | None = None
    """
    Value used for comparison against message data for state detection
    """

    operator: StateTransitionsRangeCustomStateOperator

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "value": self.value,
            "operator": self.operator,
        }


@dataclass(kw_only=True)
class StateTransitionsRangeCustomStates(_BaseModel):
    """
    Range state customization strategy.
    """

    states: list[StateTransitionsRangeCustomState]
    """
    The list of range states to display in the panel.
    """

    otherwise: StateTransitionsBaseCustomState = field(
        default_factory=StateTransitionsBaseCustomState
    )

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "range",
            "states": self.states,
            "otherwise": self.otherwise,
        }


@dataclass(kw_only=True)
class StateTransitionsDiscreteCustomState(StateTransitionsBaseCustomState):
    """
    A discrete state customization strategy
    """

    value: str
    """
    Value used for comparison against message data for state detection. The comparison is done using the '=' operator.
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "value": self.value,
        }


@dataclass(kw_only=True)
class StateTransitionsDiscreteCustomStates(_BaseModel):
    """
    Discrete state customization strategy
    """

    states: list[StateTransitionsDiscreteCustomState]
    """
    The list of discrete states to display in the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "discrete",
            "states": self.states,
        }


StateTransitionsCustomStates = (
    StateTransitionsRangeCustomStates | StateTransitionsDiscreteCustomStates
)

StateTransitionsTimestampMethod = Literal[
    "receiveTime", "publishTime", "headerStamp", "customField"
]


@dataclass(kw_only=True)
class StateTransitionsSeries(_BaseModel):
    """
    A series to display in the panel.
    """

    value: str
    """
    Message path containing values for the series
    """

    label: str | None = None
    """
    Label displayed in the legend for the series
    """

    enabled: bool | None = None
    """
    Whether the series is enabled. If disabled, the series will not be displayed in the panel.
    """

    timestamp_method: StateTransitionsTimestampMethod

    timestamp_path: str | None = None
    """
    Message path containing a timestamp field on the same topic as the y-value path
    """

    custom_states: StateTransitionsCustomStates | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "value": self.value,
            "label": self.label,
            "enabled": self.enabled,
            "timestampMethod": self.timestamp_method,
            "timestampPath": self.timestamp_path,
            "customStates": self.custom_states,
        }


StateTransitionsPlaybackBarPosition = Literal["center", "right"]

StateTransitionsTimeWindowMode = Literal["automatic", "sliding", "fixed"]


@dataclass(kw_only=True)
class StateTransitionsConfig(_BaseModel):
    """
    Configuration for the State Transitions panel.
    """

    paths: list[StateTransitionsSeries]
    """
    The list of series to display in the panel.
    """

    is_synced: bool
    """
    Sync zooming and panning with other plots
    """

    x_axis_max_value: float | None = None
    """
    Minimum time value to display (in seconds)
    """

    x_axis_min_value: float | None = None
    """
    Maximum time value to display (in seconds)
    """

    x_axis_range: float | None = None
    """
    Time range in seconds
    """

    x_axis_label: str | None = None
    """
    Label displayed along the time axis
    """

    time_window_mode: StateTransitionsTimeWindowMode | None = None

    playback_bar_position: StateTransitionsPlaybackBarPosition | None = None

    show_points: bool | None = None
    """
    Show a point for each incoming message
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "paths": self.paths,
            "isSynced": self.is_synced,
            "xAxisMaxValue": self.x_axis_max_value,
            "xAxisMinValue": self.x_axis_min_value,
            "xAxisRange": self.x_axis_range,
            "xAxisLabel": self.x_axis_label,
            "timeWindowMode": self.time_window_mode,
            "playbackBarPosition": self.playback_bar_position,
            "showPoints": self.show_points,
        }


@dataclass(kw_only=True)
class StateTransitionsPanel(BasePanel):
    """
    Track when values change over time.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/state-transitions).
    """

    config: StateTransitionsConfig

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "StateTransitions",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class PlotSeries(_BaseModel):
    value: str
    """
    Message path containing y-axis values for the series
    """

    enabled: bool
    """
    Whether the series is enabled. If disabled, the series will not be displayed in the panel.
    """

    id: str | None = None
    """
    A unique identifier for the series.
    """

    color: str | None = None
    """
    Color used to plot the series
    """

    label: str | None = None
    """
    Label displayed for the series in the legend
    """

    timestamp_method: Literal[
        "receiveTime", "publishTime", "headerStamp", "customField"
    ]
    """
    For Timestamp plots, set which source of time information is used for message ordering:
    - receiveTime is the standard timestamp used for playback message ordering across the app. For live connections, this is when the message was received; for recorded files, this is when the message was originally recorded
    - customField is a message path which can point to any field within the message data containing sec and nsec integers
    - headerStamp is a header.stamp ROS 1 or ROS 2 field containing sec and nsec integers (and special case of 'custom field', above). This typically represents when sensor data was captured
    - publishTime is an optional MCAP-specific field representing when the event occured
    """

    timestamp_path: str | None = None
    """
    Message path containing a timestamp field on the same topic as the y-value path
    """

    show_line: bool | None = None
    """
    Show line connecting data points. (Not applicable to reference lines.)
    """

    line_size: float | None = None
    """
    Width of line connecting data points
    """

    x_value_path: str | None = None
    """
    For Message path plots: message path containing x-axis values for the series. Overrides default x-axis values if set.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "value": self.value,
            "enabled": self.enabled,
            "id": self.id,
            "color": self.color,
            "label": self.label,
            "timestampMethod": self.timestamp_method,
            "timestampPath": self.timestamp_path,
            "showLine": self.show_line,
            "lineSize": self.line_size,
            "xValuePath": self.x_value_path,
        }


@dataclass(kw_only=True)
class PlotXAxisPath(_BaseModel):
    """
    For path-based values: the message path containing default x-axis values for the series. You can also set these individually for each series.
    """

    value: str
    """
    Message path containing y-axis values for the series
    """

    enabled: bool
    """
    Whether the series is enabled. If disabled, the series will not be displayed in the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "value": self.value,
            "enabled": self.enabled,
        }


@dataclass(kw_only=True)
class PlotConfig(_BaseModel):
    """
    Configuration for the Plot panel.
    """

    paths: list[PlotSeries]
    """
    The list of series to display in the panel.
    """

    min_x_value: float | None = None
    """
    For Fixed time window: min value in seconds
    """

    max_x_value: float | None = None
    """
    For Fixed time window: max value in seconds
    """

    min_y_value: str | float | None = None
    """
    Fixed minimum value for y-axis
    """

    max_y_value: str | float | None = None
    """
    Fixed maximum value for y-axis
    """

    show_legend: bool
    """
    Display the legend
    """

    legend_display: Literal["floating", "top", "left"]
    """
    Position of the legend in relation to the chart
    """

    show_plot_values_in_legend: bool
    """
    Show the corresponding y value next to each series in the legend (either at the current playback time or at a point on user hover)
    """

    show_x_axis_labels: bool
    """
    Whether or not to display numeric values for x-axis tick marks
    """

    show_y_axis_labels: bool
    """
    Whether or not to display numeric values for y-axis tick marks
    """

    is_synced: bool
    """
    For Timestamp plots: Sync timeline to other Plot and State Transitions panels.
    """

    x_axis_val: Literal["timestamp", "index", "custom", "currentCustom"]
    """
    Type and source of data for values plotted on the x-axis:
    - Timestamp: x-values for time series data
    - Message path: numeric message fields for XY plots
    - Array index: integer indices of an array in the latest message
    """

    time_range: Literal["all", "latest"] | None = None
    """
    For Message path plots:
    - All shows data from the full time range
    - Latest shows data from the most recent message.
    """

    x_axis_path: PlotXAxisPath | None = None

    x_axis_label: str | None = None
    """
    Label displayed for the x-axis
    """

    time_window_mode: Literal["automatic", "sliding", "fixed"] | None = None
    """
    For Timestamp plots:
    - Automatic Last 30 seconds for live data, or the full time range for recorded data
    - Sliding Specify a sliding time window that follows the current playback time
    - Fixed Set fixed min and max values for the time axis
    """

    playback_bar_position: Literal["center", "right"] | None = None
    """
    For Sliding time window: either at the center or the right edge
    """

    y_axis_label: str | None = None
    """
    Label displayed for the y-axis
    """

    following_view_width: float | None = None
    """
    For Sliding time window: range of time in seconds
    """

    sidebar_dimension: float
    """
    Size of the legend in pixels, when the legend position is Left or Top
    """

    axis_scales_mode: Literal["independent", "lockedScales"] | None = None
    """
    For Message path plots:
    - Independent (the default) lets you configure min and max values for the scales independently.
    - 1:1 is useful for when axes have the same units, and will keep the scales locked together. It hides the min/max axis settings and always zooms both axes simultaneously.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "paths": self.paths,
            "minXValue": self.min_x_value,
            "maxXValue": self.max_x_value,
            "minYValue": self.min_y_value,
            "maxYValue": self.max_y_value,
            "showLegend": self.show_legend,
            "legendDisplay": self.legend_display,
            "showPlotValuesInLegend": self.show_plot_values_in_legend,
            "showXAxisLabels": self.show_x_axis_labels,
            "showYAxisLabels": self.show_y_axis_labels,
            "isSynced": self.is_synced,
            "xAxisVal": self.x_axis_val,
            "timeRange": self.time_range,
            "xAxisPath": self.x_axis_path,
            "xAxisLabel": self.x_axis_label,
            "timeWindowMode": self.time_window_mode,
            "playbackBarPosition": self.playback_bar_position,
            "yAxisLabel": self.y_axis_label,
            "followingViewWidth": self.following_view_width,
            "sidebarDimension": self.sidebar_dimension,
            "axisScalesMode": self.axis_scales_mode,
        }


@dataclass(kw_only=True)
class PlotPanel(BasePanel):
    """
    Plot numerical values over time or other values.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/plot).
    """

    config: PlotConfig

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Plot",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class TransformTreePanel(BasePanel):
    """
    Display the transform tree.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/tf-tree).
    """

    config: Any | None = None

    title: Any | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "TransformTree",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


BaseRendererMeshUpAxis = Literal["y_up", "z_up"]


@dataclass(kw_only=True)
class BaseRendererBaseSettings(_BaseModel):
    visible: bool | None = None
    """
    Whether this renderable should be displayed in the scene.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "visible": self.visible,
        }


@dataclass(kw_only=True)
class BaseRendererCameraTopicSettings(BaseRendererBaseSettings):
    distance: float | None = None

    planar_projection_factor: float | None = None

    width: float | None = None

    color: str | None = None

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "distance": self.distance,
            "planarProjectionFactor": self.planar_projection_factor,
            "width": self.width,
            "color": self.color,
        }


@dataclass(kw_only=True)
class BaseRendererOccupancyGridTopicSettings(BaseRendererBaseSettings):
    min_color: str | None = None

    max_color: str | None = None

    unknown_color: str | None = None

    invalid_color: str | None = None

    color_mode: Literal["custom", "costmap", "map", "raw"] | None = None

    draw_behind: bool | None = None

    alpha: float | None = None

    frame_locked: bool | None = None
    """
    true means the grid is locked to the frame specified by its frame_id, and will move as that frame's transforms change. false means the grid is relative to the fixed frame and will not move after it is first displayed.
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "minColor": self.min_color,
            "maxColor": self.max_color,
            "unknownColor": self.unknown_color,
            "invalidColor": self.invalid_color,
            "colorMode": self.color_mode,
            "drawBehind": self.draw_behind,
            "alpha": self.alpha,
            "frameLocked": self.frame_locked,
        }


@dataclass(kw_only=True)
class BaseRendererPolygonTopicSettings(BaseRendererBaseSettings):
    line_width: float | None = None

    color: str | None = None

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "lineWidth": self.line_width,
            "color": self.color,
        }


BaseRendererTopicSettings = (
    BaseRendererCameraTopicSettings
    | BaseRendererOccupancyGridTopicSettings
    | BaseRendererPolygonTopicSettings
)


@dataclass(kw_only=True)
class BaseRendererLayerSettingsTransform(BaseRendererBaseSettings):
    xyz_offset: tuple[float, float, float] | None = None

    rpy_coefficient: tuple[float, float, float] | None = None

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "xyzOffset": self.xyz_offset,
            "rpyCoefficient": self.rpy_coefficient,
        }


@dataclass(kw_only=True)
class BaseRendererCustomLayerSettings(BaseRendererBaseSettings):
    instance_id: str | None = None
    """
    An identifier for a unique instance of a layer.
    """

    layer_id: str | None = None
    """
    An identifier for a type of layer, such as `"foxglove.Grid"`.
    """

    label: str | None = None
    """
    The label to use for this layer in the settings tree, under "Custom Layers".
    """

    order: float | None = None
    """
    Optional value specifying order in the custom layer list
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "instanceId": self.instance_id,
            "layerId": self.layer_id,
            "label": self.label,
            "order": self.order,
        }


@dataclass(kw_only=True)
class BaseRendererSceneSettings(_BaseModel):
    """
    Scene settings for the currently rendering scene
    """

    enable_stats: bool | None = None
    """
    Display rendering performance statistics in panel
    """

    background_color: str | None = None
    """
    Background color of the scene
    """

    label_scale_factor: float | None = None
    """
    Scale factor to apply to all rendered labels
    """

    ignore_collada_up_axis: bool | None = None
    """
    Match the behavior of RViz by ignoring the <up_axis> tag in COLLADA files
    """

    mesh_up_axis: BaseRendererMeshUpAxis | None = None

    transforms: BaseRendererTransforms | None = None

    sync_camera: bool | None = None
    """
    Sync the camera with other panels that also have this setting enabled
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "enableStats": self.enable_stats,
            "backgroundColor": self.background_color,
            "labelScaleFactor": self.label_scale_factor,
            "ignoreColladaUpAxis": self.ignore_collada_up_axis,
            "meshUpAxis": self.mesh_up_axis,
            "transforms": self.transforms,
            "syncCamera": self.sync_camera,
        }


@dataclass(kw_only=True)
class BaseRendererTransforms(_BaseModel):
    """
    Transform settings for the currently rendering scene
    """

    visible: bool | None = None
    """
    Toggle visibility of all frames
    """

    editable: bool | None = None
    """
    Toggle translation and rotation offset controls for frames
    """

    show_label: bool | None = None
    """
    Toggle visibility of frame axis labels
    """

    label_size: float | None = None
    """
    Size of frame axis labels
    """

    axis_size: float | None = None
    """
    Size of coordinate frame axes
    """

    line_width: float | None = None
    """
    Width of the connecting line between child and parent frames
    """

    line_color: str | None = None
    """
    Color of the connecting line between child and parent frames
    """

    enable_preloading: bool | None = None
    """
    Enable transform preloading
    """

    draw_behind: bool | None = None
    """
    Whether to draw the frames behind the rest of the scene
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "visible": self.visible,
            "editable": self.editable,
            "showLabel": self.show_label,
            "labelSize": self.label_size,
            "axisSize": self.axis_size,
            "lineWidth": self.line_width,
            "lineColor": self.line_color,
            "enablePreloading": self.enable_preloading,
            "drawBehind": self.draw_behind,
        }


@dataclass(kw_only=True)
class BaseRendererConfig(_BaseModel):
    """
    Base configuration for the 3D and Image panels
    """

    scene: BaseRendererSceneSettings | None = None

    transforms: dict[str, BaseRendererLayerSettingsTransform] | None = None
    """
    frameId -> settings
    """

    layers: dict[str, BaseRendererCustomLayerSettings] | None = None
    """
    Settings for layers in the scene, indexed by instanceId.
    """

    topics: dict[str, BaseRendererTopicSettings] | None = None
    """
    Settings for topics, indexed by topicName
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "scene": self.scene,
            "transforms": self.transforms,
            "layers": self.layers,
            "topics": self.topics,
        }


@dataclass(kw_only=True)
class ThreeDeeCameraState(_BaseModel):
    """
    Camera settings for the currently rendering scene
    """

    distance: float | None = None
    """
    Camera distance from the origin of the display frame
    """

    perspective: bool | None = None
    """
    Toggles between 3D and 2D views of the scene. The 2D view looks down the z-axis of the fixed frame and flattens the scene against its x-y plane.
    """

    phi: float | None = None
    """
    Polar angle offset from the origin of the display frame in degrees
    """

    target: tuple[float, float, float] | None = None

    target_offset: tuple[float, float, float] | None = None
    """
    Translational offset from the origin of the display frame
    """

    target_orientation: tuple[float, float, float, float] | None = None

    theta_offset: float | None = None
    """
    Azimuthal angle offset from the origin of the display frame in degrees
    """

    fovy: float | None = None
    """
    Vertical field of view in degrees
    """

    near: float | None = None
    """
    Near clipping plane distance
    """

    far: float | None = None
    """
    Far clipping plane distance
    """

    log_depth: bool | None = None
    """
    Enable logarithmic depth buffer for more uniform depth precision. May result in rendering artifacts or performance degradation.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "distance": self.distance,
            "perspective": self.perspective,
            "phi": self.phi,
            "target": self.target,
            "targetOffset": self.target_offset,
            "targetOrientation": self.target_orientation,
            "thetaOffset": self.theta_offset,
            "fovy": self.fovy,
            "near": self.near,
            "far": self.far,
            "logDepth": self.log_depth,
        }


ThreeDeeFollowMode = Literal["follow-pose", "follow-position", "follow-none"]


@dataclass(kw_only=True)
class ThreeDeePublishSettings(_BaseModel):
    """
    Publish settings for the currently rendering scene
    """

    type: ThreeDeePublishClickType | None = None

    pose_topic: str | None = None
    """
    The topic on which to publish
    """

    point_topic: str | None = None
    """
    The topic on which to publish
    """

    pose_estimate_topic: str | None = None
    """
    The topic on which to publish
    """

    pose_estimate_x_deviation: float | None = None
    """
    The X standard deviation to publish with pose estimates
    """

    pose_estimate_y_deviation: float | None = None
    """
    The Y standard deviation to publish with pose estimates
    """

    pose_estimate_theta_deviation: float | None = None
    """
    The theta standard deviation to publish with pose estimates
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": self.type,
            "poseTopic": self.pose_topic,
            "pointTopic": self.point_topic,
            "poseEstimateTopic": self.pose_estimate_topic,
            "poseEstimateXDeviation": self.pose_estimate_x_deviation,
            "poseEstimateYDeviation": self.pose_estimate_y_deviation,
            "poseEstimateThetaDeviation": self.pose_estimate_theta_deviation,
        }


ThreeDeePublishClickType = Literal["pose_estimate", "pose", "point"]


@dataclass(kw_only=True)
class ThreeDeeOverlaySettings(_BaseModel):
    visible: bool | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "visible": self.visible,
        }


@dataclass(kw_only=True)
class ThreeDeeConfig(BaseRendererConfig):
    """
    Configuration for the 3D panel
    """

    camera_state: ThreeDeeCameraState | None = None

    follow_tf: str | None = None
    """
    Coordinate frame that the scene is rendered relative to. The camera position and orientation will be relative to the origin of this frame.
    """

    fixed_frame: str | None = None
    """
    The stationary world reference relative to which all other objects in the scene are located. Elements that accumulate over time (for example, point clouds) are stored and displayed in this frame, and in 2D mode the camera faces this frame's x-y plane.
    """

    follow_mode: ThreeDeeFollowMode | None = None

    location_fix_topic: str | None = None
    """
    Topic containing location fix data associated with a frame in the scene. Auto will use the first available topic.
    """

    enu_frame_id: str | None = None
    """
    Defines the East-North-Up orientation of the scene. Maps and location fixes will be aligned relative to the XY plane of this frame.
    """

    publish: ThreeDeePublishSettings | None = None

    panel_overlays: dict[str, ThreeDeeOverlaySettings] | None = None
    """
    instanceId -> settings
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "cameraState": self.camera_state,
            "followTf": self.follow_tf,
            "fixedFrame": self.fixed_frame,
            "followMode": self.follow_mode,
            "locationFixTopic": self.location_fix_topic,
            "enuFrameId": self.enu_frame_id,
            "publish": self.publish,
            "panelOverlays": self.panel_overlays,
        }


@dataclass(kw_only=True)
class ThreeDeePanel(BasePanel):
    """
    Display markers, camera images, meshes, URDFs, and more in a 3D scene.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/3d).
    """

    config: ThreeDeeConfig = field(default_factory=ThreeDeeConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "ThreeDee",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class ImageAnnotationSettings(_BaseModel):
    visible: bool | None = None
    """
    Whether to display the annotation.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "visible": self.visible,
        }


@dataclass(kw_only=True)
class ImageModeConfig(_BaseModel):
    image_topic: str | None = None
    """
    Camera image or video topic to display.
    """

    image_schema_name: str | None = None
    """
    Message schema to display
    """

    calibration_topic: str | None = None
    """
    Calibration topic to use for distortion and 3D markers
    """

    annotations: dict[str, ImageAnnotationSettings] | None = None
    """
    Settings for the image annotations, indexed by topicName
    """

    synchronize: bool | None = None
    """
    Display annotations only when their messages' timestamps match
    """

    rotation: Literal[0, 90, 180, 270] | None = None
    """
    Amount of image rotation
    """

    flip_horizontal: bool | None = None
    """
    Flip image across the vertical axis
    """

    flip_vertical: bool | None = None
    """
    Flip image across the horizontal axis
    """

    min_value: float | None = None
    """
    Minimum (black) value for single-channel images.
    """

    max_value: float | None = None
    """
    Maximum (white) value for single-channel images.
    """

    video_decoder: str | None = None
    """
    Video decoder
    """

    rectify_image: bool | None = None
    """
    Whether to rectify (undistort) the image. If turned off, images will be displayed as is and 3D topic visualization will be disabled.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "imageTopic": self.image_topic,
            "imageSchemaName": self.image_schema_name,
            "calibrationTopic": self.calibration_topic,
            "annotations": self.annotations,
            "synchronize": self.synchronize,
            "rotation": self.rotation,
            "flipHorizontal": self.flip_horizontal,
            "flipVertical": self.flip_vertical,
            "minValue": self.min_value,
            "maxValue": self.max_value,
            "videoDecoder": self.video_decoder,
            "rectifyImage": self.rectify_image,
        }


@dataclass(kw_only=True)
class ImageConfig(BaseRendererConfig):
    """
    Configuration for the image panel.
    """

    image_mode: ImageModeConfig | None = None

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "imageMode": self.image_mode,
        }


@dataclass(kw_only=True)
class ImagePanel(BasePanel):
    """
    Display annotated images.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/image).
    """

    config: ImageConfig = field(default_factory=ImageConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Image",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class AudioConfig(_BaseModel):
    """
    Configuration for the Audio panel.
    """

    color: str | None = None
    """
    Color of the audio waveform visualization
    """

    muted: bool | None = None
    """
    Mute audio playback
    """

    topic: str | None = None
    """
    Topic containing audio messages
    """

    volume: float | None = None
    """
    Audio playback volume
    """

    sliding_view_width: float | None = None
    """
    Time range in seconds for the sliding window (live sources only)
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "color": self.color,
            "muted": self.muted,
            "topic": self.topic,
            "volume": self.volume,
            "slidingViewWidth": self.sliding_view_width,
        }


@dataclass(kw_only=True)
class AudioPanel(BasePanel):
    """
    Play audio streams.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/audio).
    """

    config: AudioConfig = field(default_factory=AudioConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Audio",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class DiagnosticsSummaryConfig(_BaseModel):
    """
    Configuration for the Diagnostic Summary panel.
    """

    min_level: float
    """
    Minimum level of diagnostic messages to display
    """

    pinned_ids: list[str]
    """
    List of diagnostic IDs to pin to the top of the list. The format is `|hardware_id|name|` or `|hardware_id|` for a hardware ID without a name.
    """

    topic_to_render: str
    """
    ROS DiagnosticArray topic to subscribe to
    """

    hardware_id_filter: str
    """
    Fuzzy filter entries by hardware ID and node names
    """

    sort_by_level: bool | None = None
    """
    Sort visible nodes by level
    """

    seconds_until_stale: float | None = None
    """
    Number of seconds after which entries will be marked as stale if no new messages are received
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "minLevel": self.min_level,
            "pinnedIds": self.pinned_ids,
            "topicToRender": self.topic_to_render,
            "hardwareIdFilter": self.hardware_id_filter,
            "sortByLevel": self.sort_by_level,
            "secondsUntilStale": self.seconds_until_stale,
        }


@dataclass(kw_only=True)
class DiagnosticsSummaryPanel(BasePanel):
    """
    Display a summary of all ROS DiagnosticArray messages.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/diagnostics).
    """

    config: DiagnosticsSummaryConfig

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "DiagnosticsSummary",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class DiagnosticsDetailConfig(_BaseModel):
    """
    Configuration for the Diagnostic Detail panel.
    """

    selected_hardware_id: str | None = None
    """
    The hardware ID of the diagnostic node to display
    """

    selected_name: str | None = None
    """
    The name of the diagnostic node to display
    """

    split_fraction: float | None = None
    """
    The fraction of the panel to split between the diagnostic node and the diagnostic status
    """

    topic_to_render: str
    """
    ROS DiagnosticArray topic to subscribe to
    """

    numeric_precision: float | None = None
    """
    Number of decimal places to display for numeric values
    """

    seconds_until_stale: float | None = None
    """
    Number of seconds after which entries will be marked as stale if no new messages are received
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "selectedHardwareId": self.selected_hardware_id,
            "selectedName": self.selected_name,
            "splitFraction": self.split_fraction,
            "topicToRender": self.topic_to_render,
            "numericPrecision": self.numeric_precision,
            "secondsUntilStale": self.seconds_until_stale,
        }


@dataclass(kw_only=True)
class DiagnosticsDetailPanel(BasePanel):
    """
    Display ROS DiagnosticArray messages for a specific hardware_id.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/diagnostics).
    """

    config: DiagnosticsDetailConfig

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "DiagnosticsDetail",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class IndicatorRule(_BaseModel):
    """
    A rule to determine what the indicator should display
    """

    raw_value: str
    """
    Value to compare against
    """

    operator: Literal["=", "<", "<=", ">", ">="]
    """
    Operator to use for the indicator rule
    """

    color: str
    """
    Color to use when the rule matches
    """

    label: str
    """
    Label to use when the rule matches
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "rawValue": self.raw_value,
            "operator": self.operator,
            "color": self.color,
            "label": self.label,
        }


@dataclass(kw_only=True)
class IndicatorConfig(_BaseModel):
    """
    Configuration for the Indicator panel.
    """

    path: str
    """
    Message path to the data
    """

    style: Literal["bulb", "background"]
    """
    Style of indicator to display
    """

    font_size: float | None = None
    """
    Font size of the indicator
    """

    rules: list[IndicatorRule]
    """
    Range rules list to determine what the indicator should display, evaluated in order of precedence
    """

    fallback_color: str
    """
    Color to use when no other rules match
    """

    fallback_label: str
    """
    Label to use when no other rules match
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "path": self.path,
            "style": self.style,
            "fontSize": self.font_size,
            "rules": self.rules,
            "fallbackColor": self.fallback_color,
            "fallbackLabel": self.fallback_label,
        }


@dataclass(kw_only=True)
class IndicatorPanel(BasePanel):
    """
    Display a colored and/or textual indicator based on a threshold value.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/indicator).
    """

    config: IndicatorConfig

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Indicator",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class GaugeConfig(_BaseModel):
    """
    Configuration for the Gauge panel.
    """

    path: str
    """
    Message path containing a numeric value (or string value that can be coerced to a numeric value)
    """

    style: Literal["dial", "bar"]
    """
    Visual style of the gauge
    """

    min_value: float
    """
    Minimum value for the gauge
    """

    max_value: float
    """
    Maximum value for the gauge
    """

    color_mode: Literal["colormap", "gradient"]
    """
    Type of gradient to use for the gauge
    """

    color_map: Literal["red-yellow-green", "rainbow", "turbo"]
    """
    Preset gradients for the gauge
    """

    gradient: tuple[str, str]
    """
    Starting and ending color stops for custom gradient
    """

    reverse: bool
    """
    Reverse the colors of the gauge
    """

    reverse_direction: bool
    """
    Reverse the direction of the gauge (min on right, max on left)
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "path": self.path,
            "style": self.style,
            "minValue": self.min_value,
            "maxValue": self.max_value,
            "colorMode": self.color_mode,
            "colorMap": self.color_map,
            "gradient": self.gradient,
            "reverse": self.reverse,
            "reverseDirection": self.reverse_direction,
        }


@dataclass(kw_only=True)
class GaugePanel(BasePanel):
    """
    Display a colored gauge based on a continuous value.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/gauge).
    """

    config: GaugeConfig

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Gauge",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class TeleopButton(_BaseModel):
    """
    A button to teleoperate a robot
    """

    field: str
    """
    Field (linear or angular x, y, or z)
    """

    value: float
    """
    Value to publish when the button is pressed
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "field": self.field,
            "value": self.value,
        }


@dataclass(kw_only=True)
class TeleopConfig(_BaseModel):
    """
    Configuration for the Teleop panel.
    """

    topic: str | None = None
    """
    Topic on which to publish geometry_msgs/Twist or geometry_msgs/msg/Twist messages
    """

    publish_rate: float | None = None
    """
    Rate at which to publish geometry_msgs/Twist or geometry_msgs/msg/Twist messages
    """

    up_button: TeleopButton

    down_button: TeleopButton

    left_button: TeleopButton

    right_button: TeleopButton

    def _to_dict(self) -> dict[str, Any]:
        return {
            "topic": self.topic,
            "publishRate": self.publish_rate,
            "upButton": self.up_button,
            "downButton": self.down_button,
            "leftButton": self.left_button,
            "rightButton": self.right_button,
        }


@dataclass(kw_only=True)
class TeleopPanel(BasePanel):
    """
    Teleoperate a robot over a live connection.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/teleop).
    """

    config: TeleopConfig

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Teleop",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class MapCoordinates(_BaseModel):
    """
    Coordinates of the center of the map
    """

    lat: float

    lon: float

    def _to_dict(self) -> dict[str, Any]:
        return {
            "lat": self.lat,
            "lon": self.lon,
        }


@dataclass(kw_only=True)
class MapTopicSettings(_BaseModel):
    history_mode: Literal["all", "none", "previous"] | None = None
    """
    Which messages to display when history (or future data via preloading) is available.
    """

    point_display_mode: Literal["dot", "pin"] | None = None
    """
    Configure GPS location display
    """

    point_size: float | None = None
    """
    Sets the diameter of points rendered on the map for this topic, in pixels
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "historyMode": self.history_mode,
            "pointDisplayMode": self.point_display_mode,
            "pointSize": self.point_size,
        }


MapLayerType = Literal[
    "street", "satellite", "custom", "shaded-relief", "seamark", "isobaths"
]


@dataclass(kw_only=True)
class MapLayerConfig(_BaseModel):
    """
    Configuration for a map layer displayed on top of the base map.
    """

    type: MapLayerType

    enabled: bool | None = None
    """
    Whether this layer is visible
    """

    opacity: float | None = None
    """
    Opacity of the layer (0 to 1)
    """

    custom_tile_url: str | None = None
    """
    URL to custom map tiles when type is 'custom', following Tile Map Service specs
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": self.type,
            "enabled": self.enabled,
            "opacity": self.opacity,
            "customTileUrl": self.custom_tile_url,
        }


@dataclass(kw_only=True)
class MapConfig(_BaseModel):
    """
    Configuration for the Map panel.
    """

    center: MapCoordinates | None = None

    custom_tile_url: str | None = None
    """
    URL to your custom map tiles following the Tile Map Service specs, e.g. https://my.custom.url/{x}/{y}/{z}.png
    """

    disabled_topics: list[str] | None = None
    """
    Topics to disable from being displayed on the map
    """

    follow_topic: str | None = None
    """
    Topic to follow in the panel viewport
    """

    follow_frame: str | None = None
    """
    The location fix to follow
    """

    layer: Literal["map", "satellite", "custom", "shaded-relief"] | None = None
    """
    Type of map to display
    """

    topic_colors: dict[str, str] | None = None
    """
    Colors for topics on the map
    """

    zoom_level: float | None = None
    """
    Zoom level of the map
    """

    max_native_zoom: float | None = None
    """
    Highest zoom supported by the custom map source
    """

    topic_config: dict[str, MapTopicSettings] | None = None
    """
    Configuration for topics on the map
    """

    layers: list[MapLayerConfig] | None = None
    """
    Additional layers displayed on top of the base map layer
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "center": self.center,
            "customTileUrl": self.custom_tile_url,
            "disabledTopics": self.disabled_topics,
            "followTopic": self.follow_topic,
            "followFrame": self.follow_frame,
            "layer": self.layer,
            "topicColors": self.topic_colors,
            "zoomLevel": self.zoom_level,
            "maxNativeZoom": self.max_native_zoom,
            "topicConfig": self.topic_config,
            "layers": self.layers,
        }


@dataclass(kw_only=True)
class MapPanel(BasePanel):
    """
    Display points on a map.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/map).
    """

    config: MapConfig = field(default_factory=MapConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Map",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class ParametersPanel(BasePanel):
    """
    Read and set parameters for a data source.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/parameters).
    """

    config: Any | None = None

    title: Any | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Parameters",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class PublishConfig(_BaseModel):
    """
    Configuration for the Publish panel.
    """

    topic_name: str | None = None
    """
    Topic to publish to
    """

    datatype: str | None = None
    """
    Message schema to publish
    """

    button_text: str | None = None
    """
    Label for the button
    """

    button_tooltip: str | None = None
    """
    Tooltip for the button
    """

    button_color: str | None = None
    """
    Color of the button
    """

    advanced_view: bool
    """
    When enabled, editing the message is allowed and the content is displayed. When disabled, only the button is visible.
    """

    value: str | None = None
    """
    JSON blob to publish
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "topicName": self.topic_name,
            "datatype": self.datatype,
            "buttonText": self.button_text,
            "buttonTooltip": self.button_tooltip,
            "buttonColor": self.button_color,
            "advancedView": self.advanced_view,
            "value": self.value,
        }


@dataclass(kw_only=True)
class PublishPanel(BasePanel):
    """
    Publish messages to the data source (live connections only).

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/publish).
    """

    config: PublishConfig

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Publish",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class ServiceCallConfig(_BaseModel):
    """
    Configuration for the Service Call panel.
    """

    service_name: str | None = None
    """
    Name of service to make a request to
    """

    request_payload: str | None = None
    """
    Request payload as JSON
    """

    layout: Literal["vertical", "horizontal"] | None = None
    """
    Positioning of request and response inputs
    """

    button_text: str | None = None
    """
    Label displayed on the button
    """

    button_tooltip: str | None = None
    """
    Text displayed when hovering over the button
    """

    button_color: str | None = None
    """
    Color of the button
    """

    editing_mode: bool | None = None
    """
    When enabled, editing the request is allowed and the response content is displayed. When disabled, only the button is visible.
    """

    timeout_seconds: float | None = None
    """
    Maximum time to wait for a response
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "serviceName": self.service_name,
            "requestPayload": self.request_payload,
            "layout": self.layout,
            "buttonText": self.button_text,
            "buttonTooltip": self.button_tooltip,
            "buttonColor": self.button_color,
            "editingMode": self.editing_mode,
            "timeoutSeconds": self.timeout_seconds,
        }


@dataclass(kw_only=True)
class ServiceCallPanel(BasePanel):
    """
    Call a service and view the service call result.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/service-call).
    """

    config: ServiceCallConfig = field(default_factory=ServiceCallConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "ServiceCall",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class RawMessagesConfig(_BaseModel):
    """
    Configuration for the Raw Messages panel.
    """

    diff_enabled: bool
    """
    Whether to enable diff mode
    """

    diff_method: Literal["custom", "previous message"]
    """
    Method to use for diffing
    """

    diff_topic_path: str
    """
    Topic path to use for diffing
    """

    expansion: Literal["all", "none"] | dict[str, Literal["c", "e"]] | None = None
    """
    Node expansion state. Can be 'all' (all nodes expanded), 'none' (all nodes collapsed), or a map of node paths to expansion states. In the map, keys are reversed node paths joined by '~', and values are 'c' (collapsed) or 'e' (expanded).
    """

    show_full_message_for_diff: bool
    """
    Whether to show the full message for diffing
    """

    topic_path: str
    """
    Message path to display
    """

    font_size: float | None = None
    """
    Font size for text display
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "diffEnabled": self.diff_enabled,
            "diffMethod": self.diff_method,
            "diffTopicPath": self.diff_topic_path,
            "expansion": self.expansion,
            "showFullMessageForDiff": self.show_full_message_for_diff,
            "topicPath": self.topic_path,
            "fontSize": self.font_size,
        }


@dataclass(kw_only=True)
class RawMessagesPanel(BasePanel):
    """
    Inspect topic messages.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/raw-messages).
    """

    config: RawMessagesConfig

    title: Any | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "RawMessages",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class LogNamespaceSettings(_BaseModel):
    visible: bool | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "visible": self.visible,
        }


@dataclass(kw_only=True)
class LogConfig(_BaseModel):
    """
    Configuration for the Log panel.
    """

    search_terms: list[str]
    """
    Search terms to filter log messages
    """

    preload: bool
    """
    Attempt to preload logs for recorded sources. If the recording contains over 100,000 messages, fallback to live mode
    """

    min_log_level: float
    """
    Minimum severity of messages to display  always enforced, even if the node name is selected or the message text matches the search filter
    """

    topic_to_render: str | None = None
    """
    Topic to display log messages from
    """

    name_filter: dict[str, LogNamespaceSettings] | None = None
    """
    Settings for each namespace, indexed by name
    """

    font_size: float | None = None
    """
    Font size for text display
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "searchTerms": self.search_terms,
            "preload": self.preload,
            "minLogLevel": self.min_log_level,
            "topicToRender": self.topic_to_render,
            "nameFilter": self.name_filter,
            "fontSize": self.font_size,
        }


@dataclass(kw_only=True)
class LogPanel(BasePanel):
    """
    Display logs by node and severity level.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/log).
    """

    config: LogConfig

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Log",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class TableConfig(_BaseModel):
    topic_path: str
    """
    Message path to display
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "topicPath": self.topic_path,
        }


@dataclass(kw_only=True)
class TablePanel(BasePanel):
    """
    Display topic messages in a tabular format.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/table).
    """

    config: TableConfig

    title: Any | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Table",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class TopicGraphPanel(BasePanel):
    """
    Display a graph of active nodes, topics, and services.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/topic-graph).
    """

    config: Any | None = None

    title: Any | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "TopicGraph",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class DataSourceInfoPanel(BasePanel):
    """
    View details like topics and timestamps for the current data source.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/data-source-info).
    """

    config: Any | None = None

    title: Any | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "DataSourceInfo",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class VariableSliderProps(_BaseModel):
    """
    Settings for the slider
    """

    min: float | None = None
    """
    Minimum value of the slider
    """

    max: float | None = None
    """
    Maximum value of the slider
    """

    step: float | None = None
    """
    Size of each incremental step in the slider
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "min": self.min,
            "max": self.max,
            "step": self.step,
        }


@dataclass(kw_only=True)
class VariableSliderConfig(_BaseModel):
    global_variable_name: str
    """
    Name of variable
    """

    slider_props: VariableSliderProps = field(default_factory=VariableSliderProps)

    def _to_dict(self) -> dict[str, Any]:
        return {
            "globalVariableName": self.global_variable_name,
            "sliderProps": self.slider_props,
        }


@dataclass(kw_only=True)
class VariableSliderPanel(BasePanel):
    """
    Update numerical variable values for a layout.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/variable-slider).
    """

    config: VariableSliderConfig

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "VariableSlider",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class UserScriptsConfig(_BaseModel):
    selected_node_id: str | None = None
    """
    The ID of the selected script.
    """

    auto_format_on_save: bool | None = None
    """
    Whether to automatically format the code on save.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "selectedNodeId": self.selected_node_id,
            "autoFormatOnSave": self.auto_format_on_save,
        }


@dataclass(kw_only=True)
class UserScriptsPanel(BasePanel):
    """
    Write custom data transformations in TypeScript.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/user-scripts).
    """

    config: UserScriptsConfig = field(default_factory=UserScriptsConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "UserScripts",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class Layout(_BaseModel):
    """
    A Foxglove layout, which describes the arrangement of panels and their configuration.
    """

    variables: Variables | None = None

    user_scripts: UserScripts | None = None

    content: Content

    def _to_dict(self) -> dict[str, Any]:
        return {
            "version": 1,
            "variables": self.variables,
            "userScripts": self.user_scripts,
            "content": self.content,
        }
