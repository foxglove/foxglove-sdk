//! Definitions for well-known Foxglove schemas
//! Generated by https://github.com/foxglove/schemas
#![allow(clippy::too_many_arguments)]
#![allow(clippy::enum_variant_names)]
#![allow(non_snake_case)]
use pyo3::prelude::*;

/// An enumeration indicating how input points should be interpreted to create lines
#[pyclass(eq, eq_int)]
#[derive(PartialEq, Clone)]
pub(crate) enum LinePrimitiveLineType {
    LineStrip = 0,
    LineLoop = 1,
    LineList = 2,
}

/// Log level
#[pyclass(eq, eq_int)]
#[derive(PartialEq, Clone)]
pub(crate) enum LogLevel {
    Unknown = 0,
    Debug = 1,
    Info = 2,
    Warning = 3,
    Error = 4,
    Fatal = 5,
}

/// An enumeration indicating which entities should match a SceneEntityDeletion command
#[pyclass(eq, eq_int)]
#[derive(PartialEq, Clone)]
pub(crate) enum SceneEntityDeletionType {
    MatchingId = 0,
    All = 1,
}

/// Numeric type
#[pyclass(eq, eq_int)]
#[derive(PartialEq, Clone)]
pub(crate) enum PackedElementFieldNumericType {
    Unknown = 0,
    Uint8 = 1,
    Int8 = 2,
    Uint16 = 3,
    Int16 = 4,
    Uint32 = 5,
    Int32 = 6,
    Float32 = 7,
    Float64 = 8,
}

/// Type of points annotation
#[pyclass(eq, eq_int)]
#[derive(PartialEq, Clone)]
pub(crate) enum PointsAnnotationType {
    Unknown = 0,
    Points = 1,
    LineLoop = 2,
    LineStrip = 3,
    LineList = 4,
}

/// Type of position covariance
#[pyclass(eq, eq_int)]
#[derive(PartialEq, Clone)]
pub(crate) enum LocationFixPositionCovarianceType {
    Unknown = 0,
    Approximated = 1,
    DiagonalKnown = 2,
    Known = 3,
}


#[pyclass]
#[derive(Clone)]
pub struct Timestamp {
    pub seconds: i64,
    pub nanos: i32,
}

#[pymethods]
impl Timestamp {
    #[new]
    fn new(seconds: i64, nanos: i32) -> Self {
        Self { seconds, nanos }
    }
}

impl From<Timestamp> for prost_types::Timestamp {
    fn from(value: Timestamp) -> Self {
        Self {
            seconds: value.seconds,
            nanos: value.nanos,
        }
    }
}

#[pyclass]
#[derive(Clone)]
pub struct Duration {
    pub seconds: u64,
    pub nanos: u32,
}

#[pymethods]
impl Duration {
    #[new]
    fn new(seconds: u64, nanos: u32) -> Self {
        Self { seconds, nanos }
    }
}

impl From<Duration> for prost_types::Duration {
    fn from(value: Duration) -> Self {
        Self {
            // todo: prost should likely be configured to use unsigned types
            seconds: value.seconds.try_into().unwrap_or_default(),
            nanos: value.nanos.try_into().unwrap_or_default(),
        }
    }
}
/// A primitive representing an arrow
#[pyclass]
#[derive(Clone)]
pub(crate) struct ArrowPrimitive {
    /// Position of the arrow's tail and orientation of the arrow. Identity orientation means the arrow points in the +x direction.
    pose: Pose,
    /// Length of the arrow shaft
    shaft_length: f64,
    /// Diameter of the arrow shaft
    shaft_diameter: f64,
    /// Length of the arrow head
    head_length: f64,
    /// Diameter of the arrow head
    head_diameter: f64,
    /// Color of the arrow
    color: Color,
}

#[pymethods]
impl ArrowPrimitive {
    #[new]
    fn new(
        pose: Pose,
        shaft_length: f64,
        shaft_diameter: f64,
        head_length: f64,
        head_diameter: f64,
        color: Color,
    ) -> Self {
        Self {
            pose,
            shaft_length,
            shaft_diameter,
            head_length,
            head_diameter,
            color,
        }
    }
}


impl From<ArrowPrimitive> for foxglove::schemas::ArrowPrimitive {
    fn from(value: ArrowPrimitive) -> Self {
        Self {
            pose: Some(value.pose.into()),
            shaft_length: value.shaft_length,
            shaft_diameter: value.shaft_diameter,
            head_length: value.head_length,
            head_diameter: value.head_diameter,
            color: Some(value.color.into()),
        }
    }
}

/// Camera calibration parameters
#[pyclass]
#[derive(Clone)]
pub(crate) struct CameraCalibration {
    /// Timestamp of calibration data
    timestamp: Timestamp,
    /// Frame of reference for the camera. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
    frame_id: String,
    /// Image width
    width: u32,
    /// Image height
    height: u32,
    /// Name of distortion model
    /// 
    /// Supported parameters: `plumb_bob` (k1, k2, p1, p2, k3) and `rational_polynomial` (k1, k2, p1, p2, k3, k4, k5, k6). Distortion models are based on [OpenCV's](https://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html) [pinhole camera model](https://en.wikipedia.org/wiki/Distortion_%28optics%29#Software_correction). This is the same [implementation used by ROS](http://docs.ros.org/en/diamondback/api/image_geometry/html/c++/pinhole__camera__model_8cpp_source.html)
    distortion_model: String,
    /// Distortion parameters
    D: Vec<f64>,
    /// Intrinsic camera matrix (3x3 row-major matrix)
    /// 
    /// A 3x3 row-major matrix for the raw (distorted) image.
    /// 
    /// Projects 3D points in the camera coordinate frame to 2D pixel coordinates using the focal lengths (fx, fy) and principal point (cx, cy).
    /// 
    /// ```
    ///     [fx  0 cx]
    /// K = [ 0 fy cy]
    ///     [ 0  0  1]
    /// ```
    /// 
    K: Vec<f64>,
    /// Rectification matrix (stereo cameras only, 3x3 row-major matrix)
    /// 
    /// A rotation matrix aligning the camera coordinate system to the ideal stereo image plane so that epipolar lines in both stereo images are parallel.
    R: Vec<f64>,
    /// Projection/camera matrix (3x4 row-major matrix)
    /// 
    /// ```
    ///     [fx'  0  cx' Tx]
    /// P = [ 0  fy' cy' Ty]
    ///     [ 0   0   1   0]
    /// ```
    /// 
    /// By convention, this matrix specifies the intrinsic (camera) matrix of the processed (rectified) image. That is, the left 3x3 portion is the normal camera intrinsic matrix for the rectified image.
    /// 
    /// It projects 3D points in the camera coordinate frame to 2D pixel coordinates using the focal lengths (fx', fy') and principal point (cx', cy') - these may differ from the values in K.
    /// 
    /// For monocular cameras, Tx = Ty = 0. Normally, monocular cameras will also have R = the identity and P[1:3,1:3] = K.
    /// 
    /// For a stereo pair, the fourth column [Tx Ty 0]' is related to the position of the optical center of the second camera in the first camera's frame. We assume Tz = 0 so both cameras are in the same stereo image plane. The first camera always has Tx = Ty = 0. For the right (second) camera of a horizontal stereo pair, Ty = 0 and Tx = -fx' * B, where B is the baseline between the cameras.
    /// 
    /// Given a 3D point [X Y Z]', the projection (x, y) of the point onto the rectified image is given by:
    /// 
    /// ```
    /// [u v w]' = P * [X Y Z 1]'
    ///        x = u / w
    ///        y = v / w
    /// ```
    /// 
    /// This holds for both images of a stereo pair.
    /// 
    P: Vec<f64>,
}

#[pymethods]
impl CameraCalibration {
    #[new]
    fn new(
        timestamp: Timestamp,
        frame_id: String,
        width: u32,
        height: u32,
        distortion_model: String,
        D: Vec<f64>,
        K: Vec<f64>,
        R: Vec<f64>,
        P: Vec<f64>,
    ) -> Self {
        Self {
            timestamp,
            frame_id,
            width,
            height,
            distortion_model,
            D,
            K,
            R,
            P,
        }
    }
}


impl From<CameraCalibration> for foxglove::schemas::CameraCalibration {
    fn from(value: CameraCalibration) -> Self {
        Self {
            timestamp: Some(value.timestamp.into()),
            frame_id: value.frame_id,
            width: value.width,
            height: value.height,
            distortion_model: value.distortion_model,
            d: value.D,
            k: value.K,
            r: value.R,
            p: value.P,
        }
    }
}

/// A circle annotation on a 2D image
#[pyclass]
#[derive(Clone)]
pub(crate) struct CircleAnnotation {
    /// Timestamp of circle
    timestamp: Timestamp,
    /// Center of the circle in 2D image coordinates (pixels).
    /// The coordinate uses the top-left corner of the top-left pixel of the image as the origin.
    position: Point2,
    /// Circle diameter in pixels
    diameter: f64,
    /// Line thickness in pixels
    thickness: f64,
    /// Fill color
    fill_color: Color,
    /// Outline color
    outline_color: Color,
}

#[pymethods]
impl CircleAnnotation {
    #[new]
    fn new(
        timestamp: Timestamp,
        position: Point2,
        diameter: f64,
        thickness: f64,
        fill_color: Color,
        outline_color: Color,
    ) -> Self {
        Self {
            timestamp,
            position,
            diameter,
            thickness,
            fill_color,
            outline_color,
        }
    }
}


impl From<CircleAnnotation> for foxglove::schemas::CircleAnnotation {
    fn from(value: CircleAnnotation) -> Self {
        Self {
            timestamp: Some(value.timestamp.into()),
            position: Some(value.position.into()),
            diameter: value.diameter,
            thickness: value.thickness,
            fill_color: Some(value.fill_color.into()),
            outline_color: Some(value.outline_color.into()),
        }
    }
}

/// A color in RGBA format
#[pyclass]
#[derive(Clone)]
pub(crate) struct Color {
    /// Red value between 0 and 1
    r: f64,
    /// Green value between 0 and 1
    g: f64,
    /// Blue value between 0 and 1
    b: f64,
    /// Alpha value between 0 and 1
    a: f64,
}

#[pymethods]
impl Color {
    #[new]
    fn new(
        r: f64,
        g: f64,
        b: f64,
        a: f64,
    ) -> Self {
        Self {
            r,
            g,
            b,
            a,
        }
    }
}


impl From<Color> for foxglove::schemas::Color {
    fn from(value: Color) -> Self {
        Self {
            r: value.r,
            g: value.g,
            b: value.b,
            a: value.a,
        }
    }
}

/// A compressed image
#[pyclass]
#[derive(Clone)]
pub(crate) struct CompressedImage {
    /// Timestamp of image
    timestamp: Timestamp,
    /// Frame of reference for the image. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
    frame_id: String,
    /// Compressed image data
    data: Vec<u8>,
    /// Image format
    /// 
    /// Supported values: image media types supported by Chrome, such as `webp`, `jpeg`, `png`
    format: String,
}

#[pymethods]
impl CompressedImage {
    #[new]
    fn new(
        timestamp: Timestamp,
        frame_id: String,
        data: Vec<u8>,
        format: String,
    ) -> Self {
        Self {
            timestamp,
            frame_id,
            data,
            format,
        }
    }
}


impl From<CompressedImage> for foxglove::schemas::CompressedImage {
    fn from(value: CompressedImage) -> Self {
        Self {
            timestamp: Some(value.timestamp.into()),
            frame_id: value.frame_id,
            data: value.data,
            format: value.format,
        }
    }
}

/// A single frame of a compressed video bitstream
#[pyclass]
#[derive(Clone)]
pub(crate) struct CompressedVideo {
    /// Timestamp of video frame
    timestamp: Timestamp,
    /// Frame of reference for the video.
    /// 
    /// The origin of the frame is the optical center of the camera. +x points to the right in the video, +y points down, and +z points into the plane of the video.
    frame_id: String,
    /// Compressed video frame data.
    /// 
    /// For packet-based video codecs this data must begin and end on packet boundaries (no partial packets), and must contain enough video packets to decode exactly one image (either a keyframe or delta frame). Note: Foxglove does not support video streams that include B frames because they require lookahead.
    /// 
    /// Specifically, the requirements for different `format` values are:
    /// 
    /// - `h264`
    ///   - Use Annex B formatted data
    ///   - Each CompressedVideo message should contain enough NAL units to decode exactly one video frame
    ///   - Each message containing a key frame (IDR) must also include a SPS NAL unit
    /// 
    /// - `h265` (HEVC)
    ///   - Use Annex B formatted data
    ///   - Each CompressedVideo message should contain enough NAL units to decode exactly one video frame
    ///   - Each message containing a key frame (IRAP) must also include relevant VPS/SPS/PPS NAL units
    /// 
    /// - `vp9`
    ///   - Each CompressedVideo message should contain exactly one video frame
    /// 
    /// - `av1`
    ///   - Use the "Low overhead bitstream format" (section 5.2)
    ///   - Each CompressedVideo message should contain enough OBUs to decode exactly one video frame
    ///   - Each message containing a key frame must also include a Sequence Header OBU
    data: Vec<u8>,
    /// Video format.
    /// 
    /// Supported values: `h264`, `h265`, `vp9`, `av1`.
    /// 
    /// Note: compressed video support is subject to hardware limitations and patent licensing, so not all encodings may be supported on all platforms. See more about [H.265 support](https://caniuse.com/hevc), [VP9 support](https://caniuse.com/webm), and [AV1 support](https://caniuse.com/av1).
    format: String,
}

#[pymethods]
impl CompressedVideo {
    #[new]
    fn new(
        timestamp: Timestamp,
        frame_id: String,
        data: Vec<u8>,
        format: String,
    ) -> Self {
        Self {
            timestamp,
            frame_id,
            data,
            format,
        }
    }
}


impl From<CompressedVideo> for foxglove::schemas::CompressedVideo {
    fn from(value: CompressedVideo) -> Self {
        Self {
            timestamp: Some(value.timestamp.into()),
            frame_id: value.frame_id,
            data: value.data,
            format: value.format,
        }
    }
}

/// A primitive representing a cylinder, elliptic cylinder, or truncated cone
#[pyclass]
#[derive(Clone)]
pub(crate) struct CylinderPrimitive {
    /// Position of the center of the cylinder and orientation of the cylinder. The flat face(s) are perpendicular to the z-axis.
    pose: Pose,
    /// Size of the cylinder's bounding box
    size: Vector3,
    /// 0-1, ratio of the diameter of the cylinder's bottom face (min z) to the bottom of the bounding box
    bottom_scale: f64,
    /// 0-1, ratio of the diameter of the cylinder's top face (max z) to the top of the bounding box
    top_scale: f64,
    /// Color of the cylinder
    color: Color,
}

#[pymethods]
impl CylinderPrimitive {
    #[new]
    fn new(
        pose: Pose,
        size: Vector3,
        bottom_scale: f64,
        top_scale: f64,
        color: Color,
    ) -> Self {
        Self {
            pose,
            size,
            bottom_scale,
            top_scale,
            color,
        }
    }
}


impl From<CylinderPrimitive> for foxglove::schemas::CylinderPrimitive {
    fn from(value: CylinderPrimitive) -> Self {
        Self {
            pose: Some(value.pose.into()),
            size: Some(value.size.into()),
            bottom_scale: value.bottom_scale,
            top_scale: value.top_scale,
            color: Some(value.color.into()),
        }
    }
}

/// A primitive representing a cube or rectangular prism
#[pyclass]
#[derive(Clone)]
pub(crate) struct CubePrimitive {
    /// Position of the center of the cube and orientation of the cube
    pose: Pose,
    /// Size of the cube along each axis
    size: Vector3,
    /// Color of the cube
    color: Color,
}

#[pymethods]
impl CubePrimitive {
    #[new]
    fn new(
        pose: Pose,
        size: Vector3,
        color: Color,
    ) -> Self {
        Self {
            pose,
            size,
            color,
        }
    }
}


impl From<CubePrimitive> for foxglove::schemas::CubePrimitive {
    fn from(value: CubePrimitive) -> Self {
        Self {
            pose: Some(value.pose.into()),
            size: Some(value.size.into()),
            color: Some(value.color.into()),
        }
    }
}

/// A transform between two reference frames in 3D space
#[pyclass]
#[derive(Clone)]
pub(crate) struct FrameTransform {
    /// Timestamp of transform
    timestamp: Timestamp,
    /// Name of the parent frame
    parent_frame_id: String,
    /// Name of the child frame
    child_frame_id: String,
    /// Translation component of the transform
    translation: Vector3,
    /// Rotation component of the transform
    rotation: Quaternion,
}

#[pymethods]
impl FrameTransform {
    #[new]
    fn new(
        timestamp: Timestamp,
        parent_frame_id: String,
        child_frame_id: String,
        translation: Vector3,
        rotation: Quaternion,
    ) -> Self {
        Self {
            timestamp,
            parent_frame_id,
            child_frame_id,
            translation,
            rotation,
        }
    }
}


impl From<FrameTransform> for foxglove::schemas::FrameTransform {
    fn from(value: FrameTransform) -> Self {
        Self {
            timestamp: Some(value.timestamp.into()),
            parent_frame_id: value.parent_frame_id,
            child_frame_id: value.child_frame_id,
            translation: Some(value.translation.into()),
            rotation: Some(value.rotation.into()),
        }
    }
}

/// An array of FrameTransform messages
#[pyclass]
#[derive(Clone)]
pub(crate) struct FrameTransforms {
    /// Array of transforms
    transforms: Vec<FrameTransform>,
}

#[pymethods]
impl FrameTransforms {
    #[new]
    fn new(
        transforms: Vec<FrameTransform>,
    ) -> Self {
        Self {
            transforms,
        }
    }
}


impl From<FrameTransforms> for foxglove::schemas::FrameTransforms {
    fn from(value: FrameTransforms) -> Self {
        Self {
            transforms: value.transforms.into_iter().map(|x| x.into()).collect(),
        }
    }
}

/// GeoJSON data for annotating maps
#[pyclass]
#[derive(Clone)]
pub(crate) struct GeoJson {
    /// GeoJSON data encoded as a UTF-8 string
    geojson: String,
}

#[pymethods]
impl GeoJson {
    #[new]
    fn new(
        geojson: String,
    ) -> Self {
        Self {
            geojson,
        }
    }
}


impl From<GeoJson> for foxglove::schemas::GeoJson {
    fn from(value: GeoJson) -> Self {
        Self {
            geojson: value.geojson,
        }
    }
}

/// A 2D grid of data
#[pyclass]
#[derive(Clone)]
pub(crate) struct Grid {
    /// Timestamp of grid
    timestamp: Timestamp,
    /// Frame of reference
    frame_id: String,
    /// Origin of grid's corner relative to frame of reference; grid is positioned in the x-y plane relative to this origin
    pose: Pose,
    /// Number of grid columns
    column_count: u32,
    /// Size of single grid cell along x and y axes, relative to `pose`
    cell_size: Vector2,
    /// Number of bytes between rows in `data`
    row_stride: u32,
    /// Number of bytes between cells within a row in `data`
    cell_stride: u32,
    /// Fields in `data`. `red`, `green`, `blue`, and `alpha` are optional for customizing the grid's color.
    fields: Vec<PackedElementField>,
    /// Grid cell data, interpreted using `fields`, in row-major (y-major) order
    data: Vec<u8>,
}

#[pymethods]
impl Grid {
    #[new]
    fn new(
        timestamp: Timestamp,
        frame_id: String,
        pose: Pose,
        column_count: u32,
        cell_size: Vector2,
        row_stride: u32,
        cell_stride: u32,
        fields: Vec<PackedElementField>,
        data: Vec<u8>,
    ) -> Self {
        Self {
            timestamp,
            frame_id,
            pose,
            column_count,
            cell_size,
            row_stride,
            cell_stride,
            fields,
            data,
        }
    }
}


impl From<Grid> for foxglove::schemas::Grid {
    fn from(value: Grid) -> Self {
        Self {
            timestamp: Some(value.timestamp.into()),
            frame_id: value.frame_id,
            pose: Some(value.pose.into()),
            column_count: value.column_count,
            cell_size: Some(value.cell_size.into()),
            row_stride: value.row_stride,
            cell_stride: value.cell_stride,
            fields: value.fields.into_iter().map(|x| x.into()).collect(),
            data: value.data,
        }
    }
}

/// Array of annotations for a 2D image
#[pyclass]
#[derive(Clone)]
pub(crate) struct ImageAnnotations {
    /// Circle annotations
    circles: Vec<CircleAnnotation>,
    /// Points annotations
    points: Vec<PointsAnnotation>,
    /// Text annotations
    texts: Vec<TextAnnotation>,
}

#[pymethods]
impl ImageAnnotations {
    #[new]
    fn new(
        circles: Vec<CircleAnnotation>,
        points: Vec<PointsAnnotation>,
        texts: Vec<TextAnnotation>,
    ) -> Self {
        Self {
            circles,
            points,
            texts,
        }
    }
}


impl From<ImageAnnotations> for foxglove::schemas::ImageAnnotations {
    fn from(value: ImageAnnotations) -> Self {
        Self {
            circles: value.circles.into_iter().map(|x| x.into()).collect(),
            points: value.points.into_iter().map(|x| x.into()).collect(),
            texts: value.texts.into_iter().map(|x| x.into()).collect(),
        }
    }
}

/// A key with its associated value
#[pyclass]
#[derive(Clone)]
pub(crate) struct KeyValuePair {
    /// Key
    key: String,
    /// Value
    value: String,
}

#[pymethods]
impl KeyValuePair {
    #[new]
    fn new(
        key: String,
        value: String,
    ) -> Self {
        Self {
            key,
            value,
        }
    }
}


impl From<KeyValuePair> for foxglove::schemas::KeyValuePair {
    fn from(value: KeyValuePair) -> Self {
        Self {
            key: value.key,
            value: value.value,
        }
    }
}

/// A single scan from a planar laser range-finder
#[pyclass]
#[derive(Clone)]
pub(crate) struct LaserScan {
    /// Timestamp of scan
    timestamp: Timestamp,
    /// Frame of reference
    frame_id: String,
    /// Origin of scan relative to frame of reference; points are positioned in the x-y plane relative to this origin; angles are interpreted as counterclockwise rotations around the z axis with 0 rad being in the +x direction
    pose: Pose,
    /// Bearing of first point, in radians
    start_angle: f64,
    /// Bearing of last point, in radians
    end_angle: f64,
    /// Distance of detections from origin; assumed to be at equally-spaced angles between `start_angle` and `end_angle`
    ranges: Vec<f64>,
    /// Intensity of detections
    intensities: Vec<f64>,
}

#[pymethods]
impl LaserScan {
    #[new]
    fn new(
        timestamp: Timestamp,
        frame_id: String,
        pose: Pose,
        start_angle: f64,
        end_angle: f64,
        ranges: Vec<f64>,
        intensities: Vec<f64>,
    ) -> Self {
        Self {
            timestamp,
            frame_id,
            pose,
            start_angle,
            end_angle,
            ranges,
            intensities,
        }
    }
}


impl From<LaserScan> for foxglove::schemas::LaserScan {
    fn from(value: LaserScan) -> Self {
        Self {
            timestamp: Some(value.timestamp.into()),
            frame_id: value.frame_id,
            pose: Some(value.pose.into()),
            start_angle: value.start_angle,
            end_angle: value.end_angle,
            ranges: value.ranges,
            intensities: value.intensities,
        }
    }
}

/// A primitive representing a series of points connected by lines
#[pyclass]
#[derive(Clone)]
pub(crate) struct LinePrimitive {
    /// Drawing primitive to use for lines
    r#type: LinePrimitiveLineType,
    /// Origin of lines relative to reference frame
    pose: Pose,
    /// Line thickness
    thickness: f64,
    /// Indicates whether `thickness` is a fixed size in screen pixels (true), or specified in world coordinates and scales with distance from the camera (false)
    scale_invariant: bool,
    /// Points along the line
    points: Vec<Point3>,
    /// Solid color to use for the whole line. One of `color` or `colors` must be provided.
    color: Color,
    /// Per-point colors (if specified, must have the same length as `points`). One of `color` or `colors` must be provided.
    colors: Vec<Color>,
    /// Indices into the `points` and `colors` attribute arrays, which can be used to avoid duplicating attribute data.
    /// 
    /// If omitted or empty, indexing will not be used. This default behavior is equivalent to specifying [0, 1, ..., N-1] for the indices (where N is the number of `points` provided).
    indices: Vec<u32>,
}

#[pymethods]
impl LinePrimitive {
    #[new]
    fn new(
        r#type: LinePrimitiveLineType,
        pose: Pose,
        thickness: f64,
        scale_invariant: bool,
        points: Vec<Point3>,
        color: Color,
        colors: Vec<Color>,
        indices: Vec<u32>,
    ) -> Self {
        Self {
            r#type,
            pose,
            thickness,
            scale_invariant,
            points,
            color,
            colors,
            indices,
        }
    }
}


impl From<LinePrimitive> for foxglove::schemas::LinePrimitive {
    fn from(value: LinePrimitive) -> Self {
        Self {
            r#type: value.r#type as i32,
            pose: Some(value.pose.into()),
            thickness: value.thickness,
            scale_invariant: value.scale_invariant,
            points: value.points.into_iter().map(|x| x.into()).collect(),
            color: Some(value.color.into()),
            colors: value.colors.into_iter().map(|x| x.into()).collect(),
            indices: value.indices,
        }
    }
}

/// A navigation satellite fix for any Global Navigation Satellite System
#[pyclass]
#[derive(Clone)]
pub(crate) struct LocationFix {
    /// Timestamp of the message
    timestamp: Timestamp,
    /// Frame for the sensor. Latitude and longitude readings are at the origin of the frame.
    frame_id: String,
    /// Latitude in degrees
    latitude: f64,
    /// Longitude in degrees
    longitude: f64,
    /// Altitude in meters
    altitude: f64,
    /// Position covariance (m^2) defined relative to a tangential plane through the reported position. The components are East, North, and Up (ENU), in row-major order.
    position_covariance: Vec<f64>,
    /// If `position_covariance` is available, `position_covariance_type` must be set to indicate the type of covariance.
    position_covariance_type: LocationFixPositionCovarianceType,
}

#[pymethods]
impl LocationFix {
    #[new]
    fn new(
        timestamp: Timestamp,
        frame_id: String,
        latitude: f64,
        longitude: f64,
        altitude: f64,
        position_covariance: Vec<f64>,
        position_covariance_type: LocationFixPositionCovarianceType,
    ) -> Self {
        Self {
            timestamp,
            frame_id,
            latitude,
            longitude,
            altitude,
            position_covariance,
            position_covariance_type,
        }
    }
}


impl From<LocationFix> for foxglove::schemas::LocationFix {
    fn from(value: LocationFix) -> Self {
        Self {
            timestamp: Some(value.timestamp.into()),
            frame_id: value.frame_id,
            latitude: value.latitude,
            longitude: value.longitude,
            altitude: value.altitude,
            position_covariance: value.position_covariance,
            position_covariance_type: value.position_covariance_type as i32,
        }
    }
}

/// A log message
#[pyclass]
#[derive(Clone)]
pub(crate) struct Log {
    /// Timestamp of log message
    timestamp: Timestamp,
    /// Log level
    level: LogLevel,
    /// Log message
    message: String,
    /// Process or node name
    name: String,
    /// Filename
    file: String,
    /// Line number in the file
    line: u32,
}

#[pymethods]
impl Log {
    #[new]
    fn new(
        timestamp: Timestamp,
        level: LogLevel,
        message: String,
        name: String,
        file: String,
        line: u32,
    ) -> Self {
        Self {
            timestamp,
            level,
            message,
            name,
            file,
            line,
        }
    }
}


impl From<Log> for foxglove::schemas::Log {
    fn from(value: Log) -> Self {
        Self {
            timestamp: Some(value.timestamp.into()),
            level: value.level as i32,
            message: value.message,
            name: value.name,
            file: value.file,
            line: value.line,
        }
    }
}

/// Command to remove previously published entities
#[pyclass]
#[derive(Clone)]
pub(crate) struct SceneEntityDeletion {
    /// Timestamp of the deletion. Only matching entities earlier than this timestamp will be deleted.
    timestamp: Timestamp,
    /// Type of deletion action to perform
    r#type: SceneEntityDeletionType,
    /// Identifier which must match if `type` is `MATCHING_ID`.
    id: String,
}

#[pymethods]
impl SceneEntityDeletion {
    #[new]
    fn new(
        timestamp: Timestamp,
        r#type: SceneEntityDeletionType,
        id: String,
    ) -> Self {
        Self {
            timestamp,
            r#type,
            id,
        }
    }
}


impl From<SceneEntityDeletion> for foxglove::schemas::SceneEntityDeletion {
    fn from(value: SceneEntityDeletion) -> Self {
        Self {
            timestamp: Some(value.timestamp.into()),
            r#type: value.r#type as i32,
            id: value.id,
        }
    }
}

/// A visual element in a 3D scene. An entity may be composed of multiple primitives which all share the same frame of reference.
#[pyclass]
#[derive(Clone)]
pub(crate) struct SceneEntity {
    /// Timestamp of the entity
    timestamp: Timestamp,
    /// Frame of reference
    frame_id: String,
    /// Identifier for the entity. A entity will replace any prior entity on the same topic with the same `id`.
    id: String,
    /// Length of time (relative to `timestamp`) after which the entity should be automatically removed. Zero value indicates the entity should remain visible until it is replaced or deleted.
    lifetime: Duration,
    /// Whether the entity should keep its location in the fixed frame (false) or follow the frame specified in `frame_id` as it moves relative to the fixed frame (true)
    frame_locked: bool,
    /// Additional user-provided metadata associated with the entity. Keys must be unique.
    metadata: Vec<KeyValuePair>,
    /// Arrow primitives
    arrows: Vec<ArrowPrimitive>,
    /// Cube primitives
    cubes: Vec<CubePrimitive>,
    /// Sphere primitives
    spheres: Vec<SpherePrimitive>,
    /// Cylinder primitives
    cylinders: Vec<CylinderPrimitive>,
    /// Line primitives
    lines: Vec<LinePrimitive>,
    /// Triangle list primitives
    triangles: Vec<TriangleListPrimitive>,
    /// Text primitives
    texts: Vec<TextPrimitive>,
    /// Model primitives
    models: Vec<ModelPrimitive>,
}

#[pymethods]
impl SceneEntity {
    #[new]
    fn new(
        timestamp: Timestamp,
        frame_id: String,
        id: String,
        lifetime: Duration,
        frame_locked: bool,
        metadata: Vec<KeyValuePair>,
        arrows: Vec<ArrowPrimitive>,
        cubes: Vec<CubePrimitive>,
        spheres: Vec<SpherePrimitive>,
        cylinders: Vec<CylinderPrimitive>,
        lines: Vec<LinePrimitive>,
        triangles: Vec<TriangleListPrimitive>,
        texts: Vec<TextPrimitive>,
        models: Vec<ModelPrimitive>,
    ) -> Self {
        Self {
            timestamp,
            frame_id,
            id,
            lifetime,
            frame_locked,
            metadata,
            arrows,
            cubes,
            spheres,
            cylinders,
            lines,
            triangles,
            texts,
            models,
        }
    }
}


impl From<SceneEntity> for foxglove::schemas::SceneEntity {
    fn from(value: SceneEntity) -> Self {
        Self {
            timestamp: Some(value.timestamp.into()),
            frame_id: value.frame_id,
            id: value.id,
            lifetime: Some(value.lifetime.into()),
            frame_locked: value.frame_locked,
            metadata: value.metadata.into_iter().map(|x| x.into()).collect(),
            arrows: value.arrows.into_iter().map(|x| x.into()).collect(),
            cubes: value.cubes.into_iter().map(|x| x.into()).collect(),
            spheres: value.spheres.into_iter().map(|x| x.into()).collect(),
            cylinders: value.cylinders.into_iter().map(|x| x.into()).collect(),
            lines: value.lines.into_iter().map(|x| x.into()).collect(),
            triangles: value.triangles.into_iter().map(|x| x.into()).collect(),
            texts: value.texts.into_iter().map(|x| x.into()).collect(),
            models: value.models.into_iter().map(|x| x.into()).collect(),
        }
    }
}

/// An update to the entities displayed in a 3D scene
#[pyclass]
#[derive(Clone)]
pub(crate) struct SceneUpdate {
    /// Scene entities to delete
    deletions: Vec<SceneEntityDeletion>,
    /// Scene entities to add or replace
    entities: Vec<SceneEntity>,
}

#[pymethods]
impl SceneUpdate {
    #[new]
    fn new(
        deletions: Vec<SceneEntityDeletion>,
        entities: Vec<SceneEntity>,
    ) -> Self {
        Self {
            deletions,
            entities,
        }
    }
}


impl From<SceneUpdate> for foxglove::schemas::SceneUpdate {
    fn from(value: SceneUpdate) -> Self {
        Self {
            deletions: value.deletions.into_iter().map(|x| x.into()).collect(),
            entities: value.entities.into_iter().map(|x| x.into()).collect(),
        }
    }
}

/// A primitive representing a 3D model file loaded from an external URL or embedded data
#[pyclass]
#[derive(Clone)]
pub(crate) struct ModelPrimitive {
    /// Origin of model relative to reference frame
    pose: Pose,
    /// Scale factor to apply to the model along each axis
    scale: Vector3,
    /// Solid color to use for the whole model if `override_color` is true.
    color: Color,
    /// Whether to use the color specified in `color` instead of any materials embedded in the original model.
    override_color: bool,
    /// URL pointing to model file. One of `url` or `data` should be provided.
    url: String,
    /// [Media type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) of embedded model (e.g. `model/gltf-binary`). Required if `data` is provided instead of `url`. Overrides the inferred media type if `url` is provided.
    media_type: String,
    /// Embedded model. One of `url` or `data` should be provided. If `data` is provided, `media_type` must be set to indicate the type of the data.
    data: Vec<u8>,
}

#[pymethods]
impl ModelPrimitive {
    #[new]
    fn new(
        pose: Pose,
        scale: Vector3,
        color: Color,
        override_color: bool,
        url: String,
        media_type: String,
        data: Vec<u8>,
    ) -> Self {
        Self {
            pose,
            scale,
            color,
            override_color,
            url,
            media_type,
            data,
        }
    }
}


impl From<ModelPrimitive> for foxglove::schemas::ModelPrimitive {
    fn from(value: ModelPrimitive) -> Self {
        Self {
            pose: Some(value.pose.into()),
            scale: Some(value.scale.into()),
            color: Some(value.color.into()),
            override_color: value.override_color,
            url: value.url,
            media_type: value.media_type,
            data: value.data,
        }
    }
}

/// A field present within each element in a byte array of packed elements.
#[pyclass]
#[derive(Clone)]
pub(crate) struct PackedElementField {
    /// Name of the field
    name: String,
    /// Byte offset from start of data buffer
    offset: u32,
    /// Type of data in the field. Integers are stored using little-endian byte order.
    r#type: PackedElementFieldNumericType,
}

#[pymethods]
impl PackedElementField {
    #[new]
    fn new(
        name: String,
        offset: u32,
        r#type: PackedElementFieldNumericType,
    ) -> Self {
        Self {
            name,
            offset,
            r#type,
        }
    }
}


impl From<PackedElementField> for foxglove::schemas::PackedElementField {
    fn from(value: PackedElementField) -> Self {
        Self {
            name: value.name,
            offset: value.offset,
            r#type: value.r#type as i32,
        }
    }
}

/// A point representing a position in 2D space
#[pyclass]
#[derive(Clone)]
pub(crate) struct Point2 {
    /// x coordinate position
    x: f64,
    /// y coordinate position
    y: f64,
}

#[pymethods]
impl Point2 {
    #[new]
    fn new(
        x: f64,
        y: f64,
    ) -> Self {
        Self {
            x,
            y,
        }
    }
}


impl From<Point2> for foxglove::schemas::Point2 {
    fn from(value: Point2) -> Self {
        Self {
            x: value.x,
            y: value.y,
        }
    }
}

/// A point representing a position in 3D space
#[pyclass]
#[derive(Clone)]
pub(crate) struct Point3 {
    /// x coordinate position
    x: f64,
    /// y coordinate position
    y: f64,
    /// z coordinate position
    z: f64,
}

#[pymethods]
impl Point3 {
    #[new]
    fn new(
        x: f64,
        y: f64,
        z: f64,
    ) -> Self {
        Self {
            x,
            y,
            z,
        }
    }
}


impl From<Point3> for foxglove::schemas::Point3 {
    fn from(value: Point3) -> Self {
        Self {
            x: value.x,
            y: value.y,
            z: value.z,
        }
    }
}

/// A collection of N-dimensional points, which may contain additional fields with information like normals, intensity, etc.
#[pyclass]
#[derive(Clone)]
pub(crate) struct PointCloud {
    /// Timestamp of point cloud
    timestamp: Timestamp,
    /// Frame of reference
    frame_id: String,
    /// The origin of the point cloud relative to the frame of reference
    pose: Pose,
    /// Number of bytes between points in the `data`
    point_stride: u32,
    /// Fields in `data`. At least 2 coordinate fields from `x`, `y`, and `z` are required for each point's position; `red`, `green`, `blue`, and `alpha` are optional for customizing each point's color.
    fields: Vec<PackedElementField>,
    /// Point data, interpreted using `fields`
    data: Vec<u8>,
}

#[pymethods]
impl PointCloud {
    #[new]
    fn new(
        timestamp: Timestamp,
        frame_id: String,
        pose: Pose,
        point_stride: u32,
        fields: Vec<PackedElementField>,
        data: Vec<u8>,
    ) -> Self {
        Self {
            timestamp,
            frame_id,
            pose,
            point_stride,
            fields,
            data,
        }
    }
}


impl From<PointCloud> for foxglove::schemas::PointCloud {
    fn from(value: PointCloud) -> Self {
        Self {
            timestamp: Some(value.timestamp.into()),
            frame_id: value.frame_id,
            pose: Some(value.pose.into()),
            point_stride: value.point_stride,
            fields: value.fields.into_iter().map(|x| x.into()).collect(),
            data: value.data,
        }
    }
}

/// An array of points on a 2D image
#[pyclass]
#[derive(Clone)]
pub(crate) struct PointsAnnotation {
    /// Timestamp of annotation
    timestamp: Timestamp,
    /// Type of points annotation to draw
    r#type: PointsAnnotationType,
    /// Points in 2D image coordinates (pixels).
    /// These coordinates use the top-left corner of the top-left pixel of the image as the origin.
    points: Vec<Point2>,
    /// Outline color
    outline_color: Color,
    /// Per-point colors, if `type` is `POINTS`, or per-segment stroke colors, if `type` is `LINE_LIST`, `LINE_STRIP` or `LINE_LOOP`.
    outline_colors: Vec<Color>,
    /// Fill color
    fill_color: Color,
    /// Stroke thickness in pixels
    thickness: f64,
}

#[pymethods]
impl PointsAnnotation {
    #[new]
    fn new(
        timestamp: Timestamp,
        r#type: PointsAnnotationType,
        points: Vec<Point2>,
        outline_color: Color,
        outline_colors: Vec<Color>,
        fill_color: Color,
        thickness: f64,
    ) -> Self {
        Self {
            timestamp,
            r#type,
            points,
            outline_color,
            outline_colors,
            fill_color,
            thickness,
        }
    }
}


impl From<PointsAnnotation> for foxglove::schemas::PointsAnnotation {
    fn from(value: PointsAnnotation) -> Self {
        Self {
            timestamp: Some(value.timestamp.into()),
            r#type: value.r#type as i32,
            points: value.points.into_iter().map(|x| x.into()).collect(),
            outline_color: Some(value.outline_color.into()),
            outline_colors: value.outline_colors.into_iter().map(|x| x.into()).collect(),
            fill_color: Some(value.fill_color.into()),
            thickness: value.thickness,
        }
    }
}

/// A position and orientation for an object or reference frame in 3D space
#[pyclass]
#[derive(Clone)]
pub(crate) struct Pose {
    /// Point denoting position in 3D space
    position: Vector3,
    /// Quaternion denoting orientation in 3D space
    orientation: Quaternion,
}

#[pymethods]
impl Pose {
    #[new]
    fn new(
        position: Vector3,
        orientation: Quaternion,
    ) -> Self {
        Self {
            position,
            orientation,
        }
    }
}


impl From<Pose> for foxglove::schemas::Pose {
    fn from(value: Pose) -> Self {
        Self {
            position: Some(value.position.into()),
            orientation: Some(value.orientation.into()),
        }
    }
}

/// A timestamped pose for an object or reference frame in 3D space
#[pyclass]
#[derive(Clone)]
pub(crate) struct PoseInFrame {
    /// Timestamp of pose
    timestamp: Timestamp,
    /// Frame of reference for pose position and orientation
    frame_id: String,
    /// Pose in 3D space
    pose: Pose,
}

#[pymethods]
impl PoseInFrame {
    #[new]
    fn new(
        timestamp: Timestamp,
        frame_id: String,
        pose: Pose,
    ) -> Self {
        Self {
            timestamp,
            frame_id,
            pose,
        }
    }
}


impl From<PoseInFrame> for foxglove::schemas::PoseInFrame {
    fn from(value: PoseInFrame) -> Self {
        Self {
            timestamp: Some(value.timestamp.into()),
            frame_id: value.frame_id,
            pose: Some(value.pose.into()),
        }
    }
}

/// An array of timestamped poses for an object or reference frame in 3D space
#[pyclass]
#[derive(Clone)]
pub(crate) struct PosesInFrame {
    /// Timestamp of pose
    timestamp: Timestamp,
    /// Frame of reference for pose position and orientation
    frame_id: String,
    /// Poses in 3D space
    poses: Vec<Pose>,
}

#[pymethods]
impl PosesInFrame {
    #[new]
    fn new(
        timestamp: Timestamp,
        frame_id: String,
        poses: Vec<Pose>,
    ) -> Self {
        Self {
            timestamp,
            frame_id,
            poses,
        }
    }
}


impl From<PosesInFrame> for foxglove::schemas::PosesInFrame {
    fn from(value: PosesInFrame) -> Self {
        Self {
            timestamp: Some(value.timestamp.into()),
            frame_id: value.frame_id,
            poses: value.poses.into_iter().map(|x| x.into()).collect(),
        }
    }
}

/// A [quaternion](https://eater.net/quaternions) representing a rotation in 3D space
#[pyclass]
#[derive(Clone)]
pub(crate) struct Quaternion {
    /// x value
    x: f64,
    /// y value
    y: f64,
    /// z value
    z: f64,
    /// w value
    w: f64,
}

#[pymethods]
impl Quaternion {
    #[new]
    fn new(
        x: f64,
        y: f64,
        z: f64,
        w: f64,
    ) -> Self {
        Self {
            x,
            y,
            z,
            w,
        }
    }
}


impl From<Quaternion> for foxglove::schemas::Quaternion {
    fn from(value: Quaternion) -> Self {
        Self {
            x: value.x,
            y: value.y,
            z: value.z,
            w: value.w,
        }
    }
}

/// A raw image
#[pyclass]
#[derive(Clone)]
pub(crate) struct RawImage {
    /// Timestamp of image
    timestamp: Timestamp,
    /// Frame of reference for the image. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
    frame_id: String,
    /// Image width
    width: u32,
    /// Image height
    height: u32,
    /// Encoding of the raw image data
    /// 
    /// Supported values: `8UC1`, `8UC3`, `16UC1` (little endian), `32FC1` (little endian), `bayer_bggr8`, `bayer_gbrg8`, `bayer_grbg8`, `bayer_rggb8`, `bgr8`, `bgra8`, `mono8`, `mono16`, `rgb8`, `rgba8`, `uyvy` or `yuv422`, `yuyv` or `yuv422_yuy2`
    encoding: String,
    /// Byte length of a single row
    step: u32,
    /// Raw image data
    data: Vec<u8>,
}

#[pymethods]
impl RawImage {
    #[new]
    fn new(
        timestamp: Timestamp,
        frame_id: String,
        width: u32,
        height: u32,
        encoding: String,
        step: u32,
        data: Vec<u8>,
    ) -> Self {
        Self {
            timestamp,
            frame_id,
            width,
            height,
            encoding,
            step,
            data,
        }
    }
}


impl From<RawImage> for foxglove::schemas::RawImage {
    fn from(value: RawImage) -> Self {
        Self {
            timestamp: Some(value.timestamp.into()),
            frame_id: value.frame_id,
            width: value.width,
            height: value.height,
            encoding: value.encoding,
            step: value.step,
            data: value.data,
        }
    }
}

/// A primitive representing a sphere or ellipsoid
#[pyclass]
#[derive(Clone)]
pub(crate) struct SpherePrimitive {
    /// Position of the center of the sphere and orientation of the sphere
    pose: Pose,
    /// Size (diameter) of the sphere along each axis
    size: Vector3,
    /// Color of the sphere
    color: Color,
}

#[pymethods]
impl SpherePrimitive {
    #[new]
    fn new(
        pose: Pose,
        size: Vector3,
        color: Color,
    ) -> Self {
        Self {
            pose,
            size,
            color,
        }
    }
}


impl From<SpherePrimitive> for foxglove::schemas::SpherePrimitive {
    fn from(value: SpherePrimitive) -> Self {
        Self {
            pose: Some(value.pose.into()),
            size: Some(value.size.into()),
            color: Some(value.color.into()),
        }
    }
}

/// A text label on a 2D image
#[pyclass]
#[derive(Clone)]
pub(crate) struct TextAnnotation {
    /// Timestamp of annotation
    timestamp: Timestamp,
    /// Bottom-left origin of the text label in 2D image coordinates (pixels).
    /// The coordinate uses the top-left corner of the top-left pixel of the image as the origin.
    position: Point2,
    /// Text to display
    text: String,
    /// Font size in pixels
    font_size: f64,
    /// Text color
    text_color: Color,
    /// Background fill color
    background_color: Color,
}

#[pymethods]
impl TextAnnotation {
    #[new]
    fn new(
        timestamp: Timestamp,
        position: Point2,
        text: String,
        font_size: f64,
        text_color: Color,
        background_color: Color,
    ) -> Self {
        Self {
            timestamp,
            position,
            text,
            font_size,
            text_color,
            background_color,
        }
    }
}


impl From<TextAnnotation> for foxglove::schemas::TextAnnotation {
    fn from(value: TextAnnotation) -> Self {
        Self {
            timestamp: Some(value.timestamp.into()),
            position: Some(value.position.into()),
            text: value.text,
            font_size: value.font_size,
            text_color: Some(value.text_color.into()),
            background_color: Some(value.background_color.into()),
        }
    }
}

/// A primitive representing a text label
#[pyclass]
#[derive(Clone)]
pub(crate) struct TextPrimitive {
    /// Position of the center of the text box and orientation of the text. Identity orientation means the text is oriented in the xy-plane and flows from -x to +x.
    pose: Pose,
    /// Whether the text should respect `pose.orientation` (false) or always face the camera (true)
    billboard: bool,
    /// Font size (height of one line of text)
    font_size: f64,
    /// Indicates whether `font_size` is a fixed size in screen pixels (true), or specified in world coordinates and scales with distance from the camera (false)
    scale_invariant: bool,
    /// Color of the text
    color: Color,
    /// Text
    text: String,
}

#[pymethods]
impl TextPrimitive {
    #[new]
    fn new(
        pose: Pose,
        billboard: bool,
        font_size: f64,
        scale_invariant: bool,
        color: Color,
        text: String,
    ) -> Self {
        Self {
            pose,
            billboard,
            font_size,
            scale_invariant,
            color,
            text,
        }
    }
}


impl From<TextPrimitive> for foxglove::schemas::TextPrimitive {
    fn from(value: TextPrimitive) -> Self {
        Self {
            pose: Some(value.pose.into()),
            billboard: value.billboard,
            font_size: value.font_size,
            scale_invariant: value.scale_invariant,
            color: Some(value.color.into()),
            text: value.text,
        }
    }
}

/// A primitive representing a set of triangles or a surface tiled by triangles
#[pyclass]
#[derive(Clone)]
pub(crate) struct TriangleListPrimitive {
    /// Origin of triangles relative to reference frame
    pose: Pose,
    /// Vertices to use for triangles, interpreted as a list of triples (0-1-2, 3-4-5, ...)
    points: Vec<Point3>,
    /// Solid color to use for the whole shape. One of `color` or `colors` must be provided.
    color: Color,
    /// Per-vertex colors (if specified, must have the same length as `points`). One of `color` or `colors` must be provided.
    colors: Vec<Color>,
    /// Indices into the `points` and `colors` attribute arrays, which can be used to avoid duplicating attribute data.
    /// 
    /// If omitted or empty, indexing will not be used. This default behavior is equivalent to specifying [0, 1, ..., N-1] for the indices (where N is the number of `points` provided).
    indices: Vec<u32>,
}

#[pymethods]
impl TriangleListPrimitive {
    #[new]
    fn new(
        pose: Pose,
        points: Vec<Point3>,
        color: Color,
        colors: Vec<Color>,
        indices: Vec<u32>,
    ) -> Self {
        Self {
            pose,
            points,
            color,
            colors,
            indices,
        }
    }
}


impl From<TriangleListPrimitive> for foxglove::schemas::TriangleListPrimitive {
    fn from(value: TriangleListPrimitive) -> Self {
        Self {
            pose: Some(value.pose.into()),
            points: value.points.into_iter().map(|x| x.into()).collect(),
            color: Some(value.color.into()),
            colors: value.colors.into_iter().map(|x| x.into()).collect(),
            indices: value.indices,
        }
    }
}

/// A vector in 2D space that represents a direction only
#[pyclass]
#[derive(Clone)]
pub(crate) struct Vector2 {
    /// x coordinate length
    x: f64,
    /// y coordinate length
    y: f64,
}

#[pymethods]
impl Vector2 {
    #[new]
    fn new(
        x: f64,
        y: f64,
    ) -> Self {
        Self {
            x,
            y,
        }
    }
}


impl From<Vector2> for foxglove::schemas::Vector2 {
    fn from(value: Vector2) -> Self {
        Self {
            x: value.x,
            y: value.y,
        }
    }
}

/// A vector in 3D space that represents a direction only
#[pyclass]
#[derive(Clone)]
pub(crate) struct Vector3 {
    /// x coordinate length
    x: f64,
    /// y coordinate length
    y: f64,
    /// z coordinate length
    z: f64,
}

#[pymethods]
impl Vector3 {
    #[new]
    fn new(
        x: f64,
        y: f64,
        z: f64,
    ) -> Self {
        Self {
            x,
            y,
            z,
        }
    }
}


impl From<Vector3> for foxglove::schemas::Vector3 {
    fn from(value: Vector3) -> Self {
        Self {
            x: value.x,
            y: value.y,
            z: value.z,
        }
    }
}


pub fn register_submodule(parent_module: &Bound<'_, PyModule>) -> PyResult<()> {
    let module = PyModule::new(parent_module.py(), "schemas")?;

    module.add_class::<Duration>()?;
    module.add_class::<Timestamp>()?;
    module.add_class::<LinePrimitiveLineType>()?;
    module.add_class::<LogLevel>()?;
    module.add_class::<SceneEntityDeletionType>()?;
    module.add_class::<PackedElementFieldNumericType>()?;
    module.add_class::<PointsAnnotationType>()?;
    module.add_class::<LocationFixPositionCovarianceType>()?;
    module.add_class::<ArrowPrimitive>()?;
    module.add_class::<CameraCalibration>()?;
    module.add_class::<CircleAnnotation>()?;
    module.add_class::<Color>()?;
    module.add_class::<CompressedImage>()?;
    module.add_class::<CompressedVideo>()?;
    module.add_class::<CylinderPrimitive>()?;
    module.add_class::<CubePrimitive>()?;
    module.add_class::<FrameTransform>()?;
    module.add_class::<FrameTransforms>()?;
    module.add_class::<GeoJson>()?;
    module.add_class::<Grid>()?;
    module.add_class::<ImageAnnotations>()?;
    module.add_class::<KeyValuePair>()?;
    module.add_class::<LaserScan>()?;
    module.add_class::<LinePrimitive>()?;
    module.add_class::<LocationFix>()?;
    module.add_class::<Log>()?;
    module.add_class::<SceneEntityDeletion>()?;
    module.add_class::<SceneEntity>()?;
    module.add_class::<SceneUpdate>()?;
    module.add_class::<ModelPrimitive>()?;
    module.add_class::<PackedElementField>()?;
    module.add_class::<Point2>()?;
    module.add_class::<Point3>()?;
    module.add_class::<PointCloud>()?;
    module.add_class::<PointsAnnotation>()?;
    module.add_class::<Pose>()?;
    module.add_class::<PoseInFrame>()?;
    module.add_class::<PosesInFrame>()?;
    module.add_class::<Quaternion>()?;
    module.add_class::<RawImage>()?;
    module.add_class::<SpherePrimitive>()?;
    module.add_class::<TextAnnotation>()?;
    module.add_class::<TextPrimitive>()?;
    module.add_class::<TriangleListPrimitive>()?;
    module.add_class::<Vector2>()?;
    module.add_class::<Vector3>()?;

    // Define as a package
    // https://github.com/PyO3/pyo3/issues/759
    let py = parent_module.py();
    py.import("sys")?
        .getattr("modules")?
        .set_item("foxglove._foxglove_py.schemas", &module)?;

    parent_module.add_submodule(&module)
}
