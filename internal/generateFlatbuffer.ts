import { FoxglovePrimitive, FoxgloveSchema } from "./types";

export const TIME_FB = `struct Time {
  sec:uint;
  nsec:uint;
}
`;

export const DURATION_FB = `struct Duration {
  sec:uint;
  nsec:uint;
}
`;

function primitiveToFlatbuffer(type: Exclude<FoxglovePrimitive, "time" | "duration">) {
  switch (type) {
    case "uint32":
      return "uint";
    case "bytes":
      return "[byte]";
    case "string":
      return "string";
    case "boolean":
      return "bool";
    case "float64":
      return "double";
  }
}

export function generateFlatbuffer(schema: FoxgloveSchema): string {
  let definition;
  const imports = new Set<string>();
  switch (schema.type) {
    case "enum": {
      const fields = schema.values.map(({ name, value, description }) => {
        if (description != undefined) {
          return `/// ${description}\n  ${name} = ${value},`;
        } else {
          return `${name} = ${value},`;
        }
      });

      // `///` comments required to show up in compiled flatbuffer schemas
      definition = `/// ${schema.description}\nenum ${schema.name} : byte {\n  ${fields.join(
        "\n\n  ",
      )}\n}\n`;
      break;
    }
    case "message": {
      const fields = schema.fields.map((field) => {
        const isArray = field.array != undefined;

        let type;
        switch (field.type.type) {
          case "enum":
            type = field.type.enum.name;
            imports.add(field.type.enum.name);
            break;
          case "nested":
            type = `foxglove.${field.type.schema.name}`;
            imports.add(field.type.schema.name);
            break;
          case "primitive":
            if (field.type.name === "time") {
              type = "Time";
              imports.add(`Time`);
            } else if (field.type.name === "duration") {
              type = "Duration";
              imports.add(`Duration`);
            } else {
              type = primitiveToFlatbuffer(field.type.name);
            }
            break;
        }
        let lengthComment;

        if (typeof field.array === "number") {
          // can't have inline comments
          lengthComment = `  /// length ${field.array}\n`;
        }
        return `${field.description
          .trim()
          .split("\n")
          .map((line) => `  /// ${line}\n`)
          .join("")}${lengthComment ?? ""}  ${field.name}:${isArray ? `[${type}]` : type};`;
      });

      definition = `/// ${schema.description}\ntable ${schema.name} {\n${fields.join(
        "\n\n",
      )}\n}\n\nroot_type ${schema.name};`;
      break;
    }
  }

  const outputSections = [
    `// Generated by https://github.com/foxglove/schemas`,

    Array.from(imports)
      .sort()
      .map((name) => `include "${name}.fbs";`)
      .join("\n"),

    `namespace foxglove;`,

    definition,
  ].filter(Boolean);

  return outputSections.join("\n\n") + "\n";
}
