import { FoxgloveMessageField, FoxglovePrimitive, FoxgloveSchema } from "./types";

// Flatbuffer only supports nested vectors via table
export const BYTE_VECTOR_FB = `table ByteVectorForNesting {
  data:[byte];
}

root_type ByteVectorForNesting;
`;

// Same as protobuf wellknown types
export const TIME_FB = `struct Time {
  sec:long;
  nsec:int;
}
`;

export const DURATION_FB = `struct Duration {
  sec:long;
  nsec:int;
}
`;

// fields that would benefit from having a default of 1
const defaultOneNumberFields = new Set(["x", "y", "z", "r", "g", "b", "a", "w"]);
function isDefaultOneField(field: FoxgloveMessageField): boolean {
  return (
    field.type.type === "primitive" &&
    field.type.name === "float64" &&
    defaultOneNumberFields.has(field.name)
  );
}

function primitiveToFlatbuffer(type: Exclude<FoxglovePrimitive, "time" | "duration">) {
  switch (type) {
    case "uint32":
      return "uint";
    case "bytes":
      return "[byte]";
    case "string":
      return "string";
    case "boolean":
      return "bool";
    case "float64":
      return "double";
  }
}

export function generateFlatbuffer(schema: FoxgloveSchema): string {
  let definition;
  const imports = new Set<string>();
  switch (schema.type) {
    case "enum": {
      const fields = schema.values.map(({ name, value, description }) => {
        if (description != undefined) {
          return `/// ${description}\n  ${name} = ${value},`;
        } else {
          return `${name} = ${value},`;
        }
      });

      // `///` comments required to show up in compiled flatbuffer schemas
      definition = `/// ${schema.description}\nenum ${schema.name} : byte {\n  ${fields.join(
        "\n\n  ",
      )}\n}\n`;
      break;
    }
    case "message": {
      const fields = schema.fields.map((field) => {
        const isArray = field.array != undefined;

        let type;
        switch (field.type.type) {
          case "enum":
            type = field.type.enum.name;
            imports.add(field.type.enum.name);
            break;
          case "nested":
            type = `foxglove.${field.type.schema.name}`;
            imports.add(field.type.schema.name);
            break;
          case "primitive":
            if (field.type.name === "time") {
              type = "Time";
              imports.add(`Time`);
            } else if (field.type.name === "duration") {
              type = "Duration";
              imports.add(`Duration`);
            } else if (field.type.name === "bytes" && isArray) {
              type = "ByteVectorForNesting";
              imports.add("ByteVectorForNesting");
            } else {
              type = primitiveToFlatbuffer(field.type.name);
            }
            break;
        }
        let lengthComment;

        if (typeof field.array === "number") {
          // can't specify length of vector outside of struct, all of these are tables
          lengthComment = `  /// length ${field.array}\n`;
        }
        return `${field.description
          .trim()
          .split("\n")
          .map((line) => `  /// ${line}\n`)
          .join("")}${
          // can't have inline comments, so the lengthComment needs to be above
          lengthComment ?? ""
          // convert field.name to lowercase for flatbuffer compilation compliance
        }  ${field.name.toLowerCase()}:${isArray ? `[${type}]` : type}${
          isDefaultOneField(field) ? ` = 1.0` : ""
        };`;
      });

      definition = `/// ${schema.description}\ntable ${schema.name} {\n${fields.join(
        "\n\n",
      )}\n}\n\nroot_type ${schema.name};`;
      break;
    }
  }

  const outputSections = [
    `// Generated by https://github.com/foxglove/schemas`,

    Array.from(imports)
      .sort()
      .map((name) => `include "${name}.fbs";`)
      .join("\n"),

    `namespace foxglove;`,

    definition,
  ].filter(Boolean);

  return outputSections.join("\n\n") + "\n";
}
