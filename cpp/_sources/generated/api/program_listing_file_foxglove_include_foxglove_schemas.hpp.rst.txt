
.. _program_listing_file_foxglove_include_foxglove_schemas.hpp:

Program Listing for File schemas.hpp
====================================

|exhale_lsh| :ref:`Return to documentation for file <file_foxglove_include_foxglove_schemas.hpp>` (``foxglove/include/foxglove/schemas.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   // Generated by https://github.com/foxglove/foxglove-sdk
   
   #pragma once
   
   #include <foxglove/error.hpp>
   #include <foxglove/schema.hpp>
   
   #include <array>
   #include <cstdint>
   #include <memory>
   #include <optional>
   #include <string>
   #include <type_traits>
   #include <vector>
   #ifndef __wasm32__
   #include <foxglove/context.hpp>
   #endif
   
   struct foxglove_channel;
   
   namespace foxglove::schemas {
   
   struct Vector3 {
     double x = 0;
   
     double y = 0;
   
     double z = 0;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct Quaternion {
     double x = 0;
   
     double y = 0;
   
     double z = 0;
   
     double w = 0;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct Pose {
     std::optional<Vector3> position;
   
     std::optional<Quaternion> orientation;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct Color {
     double r = 0;
   
     double g = 0;
   
     double b = 0;
   
     double a = 0;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct ArrowPrimitive {
     std::optional<Pose> pose;
   
     double shaft_length = 0;
   
     double shaft_diameter = 0;
   
     double head_length = 0;
   
     double head_diameter = 0;
   
     std::optional<Color> color;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct Timestamp {
     uint32_t sec = 0;
   
     uint32_t nsec = 0;
   };
   
   struct CameraCalibration {
     std::optional<Timestamp> timestamp;
   
     std::string frame_id;
   
     uint32_t width = 0;
   
     uint32_t height = 0;
   
     std::string distortion_model;
   
     std::vector<double> d;
   
     std::array<double, 9> k;
   
     std::array<double, 9> r;
   
     std::array<double, 12> p;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct Point2 {
     double x = 0;
   
     double y = 0;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct CircleAnnotation {
     std::optional<Timestamp> timestamp;
   
     std::optional<Point2> position;
   
     double diameter = 0;
   
     double thickness = 0;
   
     std::optional<Color> fill_color;
   
     std::optional<Color> outline_color;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct CompressedImage {
     std::optional<Timestamp> timestamp;
   
     std::string frame_id;
   
     std::vector<std::byte> data;
   
     std::string format;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct CompressedVideo {
     std::optional<Timestamp> timestamp;
   
     std::string frame_id;
   
     std::vector<std::byte> data;
   
     std::string format;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct CylinderPrimitive {
     std::optional<Pose> pose;
   
     std::optional<Vector3> size;
   
     double bottom_scale = 0;
   
     double top_scale = 0;
   
     std::optional<Color> color;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct CubePrimitive {
     std::optional<Pose> pose;
   
     std::optional<Vector3> size;
   
     std::optional<Color> color;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct Duration {
     int32_t sec = 0;
   
     uint32_t nsec = 0;
   };
   
   struct FrameTransform {
     std::optional<Timestamp> timestamp;
   
     std::string parent_frame_id;
   
     std::string child_frame_id;
   
     std::optional<Vector3> translation;
   
     std::optional<Quaternion> rotation;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct FrameTransforms {
     std::vector<FrameTransform> transforms;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct GeoJSON {
     std::string geojson;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct Vector2 {
     double x = 0;
   
     double y = 0;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct PackedElementField {
     enum class NumericType : uint8_t {
       UNKNOWN = 0,
       UINT8 = 1,
       INT8 = 2,
       UINT16 = 3,
       INT16 = 4,
       UINT32 = 5,
       INT32 = 6,
       FLOAT32 = 7,
       FLOAT64 = 8,
     };
     std::string name;
   
     uint32_t offset = 0;
   
     NumericType type;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct Grid {
     std::optional<Timestamp> timestamp;
   
     std::string frame_id;
   
     std::optional<Pose> pose;
   
     uint32_t column_count = 0;
   
     std::optional<Vector2> cell_size;
   
     uint32_t row_stride = 0;
   
     uint32_t cell_stride = 0;
   
     std::vector<PackedElementField> fields;
   
     std::vector<std::byte> data;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct VoxelGrid {
     std::optional<Timestamp> timestamp;
   
     std::string frame_id;
   
     std::optional<Pose> pose;
   
     uint32_t row_count = 0;
   
     uint32_t column_count = 0;
   
     std::optional<Vector3> cell_size;
   
     uint32_t slice_stride = 0;
   
     uint32_t row_stride = 0;
   
     uint32_t cell_stride = 0;
   
     std::vector<PackedElementField> fields;
   
     std::vector<std::byte> data;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct PointsAnnotation {
     enum class PointsAnnotationType : uint8_t {
       UNKNOWN = 0,
       POINTS = 1,
       LINE_LOOP = 2,
       LINE_STRIP = 3,
       LINE_LIST = 4,
     };
     std::optional<Timestamp> timestamp;
   
     PointsAnnotationType type;
   
     std::vector<Point2> points;
   
     std::optional<Color> outline_color;
   
     std::vector<Color> outline_colors;
   
     std::optional<Color> fill_color;
   
     double thickness = 0;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct TextAnnotation {
     std::optional<Timestamp> timestamp;
   
     std::optional<Point2> position;
   
     std::string text;
   
     double font_size = 0;
   
     std::optional<Color> text_color;
   
     std::optional<Color> background_color;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct ImageAnnotations {
     std::vector<CircleAnnotation> circles;
   
     std::vector<PointsAnnotation> points;
   
     std::vector<TextAnnotation> texts;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct KeyValuePair {
     std::string key;
   
     std::string value;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct LaserScan {
     std::optional<Timestamp> timestamp;
   
     std::string frame_id;
   
     std::optional<Pose> pose;
   
     double start_angle = 0;
   
     double end_angle = 0;
   
     std::vector<double> ranges;
   
     std::vector<double> intensities;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct Point3 {
     double x = 0;
   
     double y = 0;
   
     double z = 0;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct LinePrimitive {
     enum class LineType : uint8_t {
       LINE_STRIP = 0,
       LINE_LOOP = 1,
       LINE_LIST = 2,
     };
     LineType type;
   
     std::optional<Pose> pose;
   
     double thickness = 0;
   
     bool scale_invariant = false;
   
     std::vector<Point3> points;
   
     std::optional<Color> color;
   
     std::vector<Color> colors;
   
     std::vector<uint32_t> indices;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct LocationFix {
     enum class PositionCovarianceType : uint8_t {
       UNKNOWN = 0,
       APPROXIMATED = 1,
       DIAGONAL_KNOWN = 2,
       KNOWN = 3,
     };
     std::optional<Timestamp> timestamp;
   
     std::string frame_id;
   
     double latitude = 0;
   
     double longitude = 0;
   
     double altitude = 0;
   
     std::array<double, 9> position_covariance;
   
     PositionCovarianceType position_covariance_type;
   
     std::optional<Color> color;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct LocationFixes {
     std::vector<LocationFix> fixes;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct Log {
     enum class LogLevel : uint8_t {
       UNKNOWN = 0,
       DEBUG = 1,
       INFO = 2,
       WARNING = 3,
       ERROR = 4,
       FATAL = 5,
     };
     std::optional<Timestamp> timestamp;
   
     LogLevel level;
   
     std::string message;
   
     std::string name;
   
     std::string file;
   
     uint32_t line = 0;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct SceneEntityDeletion {
     enum class SceneEntityDeletionType : uint8_t {
       MATCHING_ID = 0,
       ALL = 1,
     };
     std::optional<Timestamp> timestamp;
   
     SceneEntityDeletionType type;
   
     std::string id;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct SpherePrimitive {
     std::optional<Pose> pose;
   
     std::optional<Vector3> size;
   
     std::optional<Color> color;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct TriangleListPrimitive {
     std::optional<Pose> pose;
   
     std::vector<Point3> points;
   
     std::optional<Color> color;
   
     std::vector<Color> colors;
   
     std::vector<uint32_t> indices;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct TextPrimitive {
     std::optional<Pose> pose;
   
     bool billboard = false;
   
     double font_size = 0;
   
     bool scale_invariant = false;
   
     std::optional<Color> color;
   
     std::string text;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct ModelPrimitive {
     std::optional<Pose> pose;
   
     std::optional<Vector3> scale;
   
     std::optional<Color> color;
   
     bool override_color = false;
   
     std::string url;
   
     std::string media_type;
   
     std::vector<std::byte> data;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct SceneEntity {
     std::optional<Timestamp> timestamp;
   
     std::string frame_id;
   
     std::string id;
   
     std::optional<Duration> lifetime;
   
     bool frame_locked = false;
   
     std::vector<KeyValuePair> metadata;
   
     std::vector<ArrowPrimitive> arrows;
   
     std::vector<CubePrimitive> cubes;
   
     std::vector<SpherePrimitive> spheres;
   
     std::vector<CylinderPrimitive> cylinders;
   
     std::vector<LinePrimitive> lines;
   
     std::vector<TriangleListPrimitive> triangles;
   
     std::vector<TextPrimitive> texts;
   
     std::vector<ModelPrimitive> models;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct SceneUpdate {
     std::vector<SceneEntityDeletion> deletions;
   
     std::vector<SceneEntity> entities;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct PointCloud {
     std::optional<Timestamp> timestamp;
   
     std::string frame_id;
   
     std::optional<Pose> pose;
   
     uint32_t point_stride = 0;
   
     std::vector<PackedElementField> fields;
   
     std::vector<std::byte> data;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct PoseInFrame {
     std::optional<Timestamp> timestamp;
   
     std::string frame_id;
   
     std::optional<Pose> pose;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct PosesInFrame {
     std::optional<Timestamp> timestamp;
   
     std::string frame_id;
   
     std::vector<Pose> poses;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct RawAudio {
     std::optional<Timestamp> timestamp;
   
     std::vector<std::byte> data;
   
     std::string format;
   
     uint32_t sample_rate = 0;
   
     uint32_t number_of_channels = 0;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   struct RawImage {
     std::optional<Timestamp> timestamp;
   
     std::string frame_id;
   
     uint32_t width = 0;
   
     uint32_t height = 0;
   
     std::string encoding;
   
     uint32_t step = 0;
   
     std::vector<std::byte> data;
   
     FoxgloveError encode(uint8_t* ptr, size_t len, size_t* encoded_len);
   
     static Schema schema();
   };
   
   #ifndef __wasm32__
   
   struct ChannelDeleter {
     void operator()(const foxglove_channel* ptr) const noexcept;
   };
   typedef std::unique_ptr<const foxglove_channel, ChannelDeleter> ChannelUniquePtr;
   
   class ArrowPrimitiveChannel {
   public:
     static FoxgloveResult<ArrowPrimitiveChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const ArrowPrimitive& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     ArrowPrimitiveChannel(const ArrowPrimitiveChannel& other) noexcept = delete;
     ArrowPrimitiveChannel& operator=(const ArrowPrimitiveChannel& other) noexcept = delete;
     ArrowPrimitiveChannel(ArrowPrimitiveChannel&& other) noexcept = default;
     ArrowPrimitiveChannel& operator=(ArrowPrimitiveChannel&& other) noexcept = default;
     ~ArrowPrimitiveChannel() = default;
   
   private:
     explicit ArrowPrimitiveChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class CameraCalibrationChannel {
   public:
     static FoxgloveResult<CameraCalibrationChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const CameraCalibration& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     CameraCalibrationChannel(const CameraCalibrationChannel& other) noexcept = delete;
     CameraCalibrationChannel& operator=(const CameraCalibrationChannel& other) noexcept = delete;
     CameraCalibrationChannel(CameraCalibrationChannel&& other) noexcept = default;
     CameraCalibrationChannel& operator=(CameraCalibrationChannel&& other) noexcept = default;
     ~CameraCalibrationChannel() = default;
   
   private:
     explicit CameraCalibrationChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class CircleAnnotationChannel {
   public:
     static FoxgloveResult<CircleAnnotationChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const CircleAnnotation& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     CircleAnnotationChannel(const CircleAnnotationChannel& other) noexcept = delete;
     CircleAnnotationChannel& operator=(const CircleAnnotationChannel& other) noexcept = delete;
     CircleAnnotationChannel(CircleAnnotationChannel&& other) noexcept = default;
     CircleAnnotationChannel& operator=(CircleAnnotationChannel&& other) noexcept = default;
     ~CircleAnnotationChannel() = default;
   
   private:
     explicit CircleAnnotationChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class ColorChannel {
   public:
     static FoxgloveResult<ColorChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const Color& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     ColorChannel(const ColorChannel& other) noexcept = delete;
     ColorChannel& operator=(const ColorChannel& other) noexcept = delete;
     ColorChannel(ColorChannel&& other) noexcept = default;
     ColorChannel& operator=(ColorChannel&& other) noexcept = default;
     ~ColorChannel() = default;
   
   private:
     explicit ColorChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class CompressedImageChannel {
   public:
     static FoxgloveResult<CompressedImageChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const CompressedImage& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     CompressedImageChannel(const CompressedImageChannel& other) noexcept = delete;
     CompressedImageChannel& operator=(const CompressedImageChannel& other) noexcept = delete;
     CompressedImageChannel(CompressedImageChannel&& other) noexcept = default;
     CompressedImageChannel& operator=(CompressedImageChannel&& other) noexcept = default;
     ~CompressedImageChannel() = default;
   
   private:
     explicit CompressedImageChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class CompressedVideoChannel {
   public:
     static FoxgloveResult<CompressedVideoChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const CompressedVideo& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     CompressedVideoChannel(const CompressedVideoChannel& other) noexcept = delete;
     CompressedVideoChannel& operator=(const CompressedVideoChannel& other) noexcept = delete;
     CompressedVideoChannel(CompressedVideoChannel&& other) noexcept = default;
     CompressedVideoChannel& operator=(CompressedVideoChannel&& other) noexcept = default;
     ~CompressedVideoChannel() = default;
   
   private:
     explicit CompressedVideoChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class CylinderPrimitiveChannel {
   public:
     static FoxgloveResult<CylinderPrimitiveChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const CylinderPrimitive& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     CylinderPrimitiveChannel(const CylinderPrimitiveChannel& other) noexcept = delete;
     CylinderPrimitiveChannel& operator=(const CylinderPrimitiveChannel& other) noexcept = delete;
     CylinderPrimitiveChannel(CylinderPrimitiveChannel&& other) noexcept = default;
     CylinderPrimitiveChannel& operator=(CylinderPrimitiveChannel&& other) noexcept = default;
     ~CylinderPrimitiveChannel() = default;
   
   private:
     explicit CylinderPrimitiveChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class CubePrimitiveChannel {
   public:
     static FoxgloveResult<CubePrimitiveChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const CubePrimitive& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     CubePrimitiveChannel(const CubePrimitiveChannel& other) noexcept = delete;
     CubePrimitiveChannel& operator=(const CubePrimitiveChannel& other) noexcept = delete;
     CubePrimitiveChannel(CubePrimitiveChannel&& other) noexcept = default;
     CubePrimitiveChannel& operator=(CubePrimitiveChannel&& other) noexcept = default;
     ~CubePrimitiveChannel() = default;
   
   private:
     explicit CubePrimitiveChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class FrameTransformChannel {
   public:
     static FoxgloveResult<FrameTransformChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const FrameTransform& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     FrameTransformChannel(const FrameTransformChannel& other) noexcept = delete;
     FrameTransformChannel& operator=(const FrameTransformChannel& other) noexcept = delete;
     FrameTransformChannel(FrameTransformChannel&& other) noexcept = default;
     FrameTransformChannel& operator=(FrameTransformChannel&& other) noexcept = default;
     ~FrameTransformChannel() = default;
   
   private:
     explicit FrameTransformChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class FrameTransformsChannel {
   public:
     static FoxgloveResult<FrameTransformsChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const FrameTransforms& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     FrameTransformsChannel(const FrameTransformsChannel& other) noexcept = delete;
     FrameTransformsChannel& operator=(const FrameTransformsChannel& other) noexcept = delete;
     FrameTransformsChannel(FrameTransformsChannel&& other) noexcept = default;
     FrameTransformsChannel& operator=(FrameTransformsChannel&& other) noexcept = default;
     ~FrameTransformsChannel() = default;
   
   private:
     explicit FrameTransformsChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class GeoJSONChannel {
   public:
     static FoxgloveResult<GeoJSONChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const GeoJSON& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     GeoJSONChannel(const GeoJSONChannel& other) noexcept = delete;
     GeoJSONChannel& operator=(const GeoJSONChannel& other) noexcept = delete;
     GeoJSONChannel(GeoJSONChannel&& other) noexcept = default;
     GeoJSONChannel& operator=(GeoJSONChannel&& other) noexcept = default;
     ~GeoJSONChannel() = default;
   
   private:
     explicit GeoJSONChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class GridChannel {
   public:
     static FoxgloveResult<GridChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const Grid& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     GridChannel(const GridChannel& other) noexcept = delete;
     GridChannel& operator=(const GridChannel& other) noexcept = delete;
     GridChannel(GridChannel&& other) noexcept = default;
     GridChannel& operator=(GridChannel&& other) noexcept = default;
     ~GridChannel() = default;
   
   private:
     explicit GridChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class VoxelGridChannel {
   public:
     static FoxgloveResult<VoxelGridChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const VoxelGrid& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     VoxelGridChannel(const VoxelGridChannel& other) noexcept = delete;
     VoxelGridChannel& operator=(const VoxelGridChannel& other) noexcept = delete;
     VoxelGridChannel(VoxelGridChannel&& other) noexcept = default;
     VoxelGridChannel& operator=(VoxelGridChannel&& other) noexcept = default;
     ~VoxelGridChannel() = default;
   
   private:
     explicit VoxelGridChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class ImageAnnotationsChannel {
   public:
     static FoxgloveResult<ImageAnnotationsChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const ImageAnnotations& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     ImageAnnotationsChannel(const ImageAnnotationsChannel& other) noexcept = delete;
     ImageAnnotationsChannel& operator=(const ImageAnnotationsChannel& other) noexcept = delete;
     ImageAnnotationsChannel(ImageAnnotationsChannel&& other) noexcept = default;
     ImageAnnotationsChannel& operator=(ImageAnnotationsChannel&& other) noexcept = default;
     ~ImageAnnotationsChannel() = default;
   
   private:
     explicit ImageAnnotationsChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class KeyValuePairChannel {
   public:
     static FoxgloveResult<KeyValuePairChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const KeyValuePair& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     KeyValuePairChannel(const KeyValuePairChannel& other) noexcept = delete;
     KeyValuePairChannel& operator=(const KeyValuePairChannel& other) noexcept = delete;
     KeyValuePairChannel(KeyValuePairChannel&& other) noexcept = default;
     KeyValuePairChannel& operator=(KeyValuePairChannel&& other) noexcept = default;
     ~KeyValuePairChannel() = default;
   
   private:
     explicit KeyValuePairChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class LaserScanChannel {
   public:
     static FoxgloveResult<LaserScanChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const LaserScan& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     LaserScanChannel(const LaserScanChannel& other) noexcept = delete;
     LaserScanChannel& operator=(const LaserScanChannel& other) noexcept = delete;
     LaserScanChannel(LaserScanChannel&& other) noexcept = default;
     LaserScanChannel& operator=(LaserScanChannel&& other) noexcept = default;
     ~LaserScanChannel() = default;
   
   private:
     explicit LaserScanChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class LinePrimitiveChannel {
   public:
     static FoxgloveResult<LinePrimitiveChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const LinePrimitive& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     LinePrimitiveChannel(const LinePrimitiveChannel& other) noexcept = delete;
     LinePrimitiveChannel& operator=(const LinePrimitiveChannel& other) noexcept = delete;
     LinePrimitiveChannel(LinePrimitiveChannel&& other) noexcept = default;
     LinePrimitiveChannel& operator=(LinePrimitiveChannel&& other) noexcept = default;
     ~LinePrimitiveChannel() = default;
   
   private:
     explicit LinePrimitiveChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class LocationFixChannel {
   public:
     static FoxgloveResult<LocationFixChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const LocationFix& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     LocationFixChannel(const LocationFixChannel& other) noexcept = delete;
     LocationFixChannel& operator=(const LocationFixChannel& other) noexcept = delete;
     LocationFixChannel(LocationFixChannel&& other) noexcept = default;
     LocationFixChannel& operator=(LocationFixChannel&& other) noexcept = default;
     ~LocationFixChannel() = default;
   
   private:
     explicit LocationFixChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class LocationFixesChannel {
   public:
     static FoxgloveResult<LocationFixesChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const LocationFixes& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     LocationFixesChannel(const LocationFixesChannel& other) noexcept = delete;
     LocationFixesChannel& operator=(const LocationFixesChannel& other) noexcept = delete;
     LocationFixesChannel(LocationFixesChannel&& other) noexcept = default;
     LocationFixesChannel& operator=(LocationFixesChannel&& other) noexcept = default;
     ~LocationFixesChannel() = default;
   
   private:
     explicit LocationFixesChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class LogChannel {
   public:
     static FoxgloveResult<LogChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const Log& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     LogChannel(const LogChannel& other) noexcept = delete;
     LogChannel& operator=(const LogChannel& other) noexcept = delete;
     LogChannel(LogChannel&& other) noexcept = default;
     LogChannel& operator=(LogChannel&& other) noexcept = default;
     ~LogChannel() = default;
   
   private:
     explicit LogChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class SceneEntityDeletionChannel {
   public:
     static FoxgloveResult<SceneEntityDeletionChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const SceneEntityDeletion& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     SceneEntityDeletionChannel(const SceneEntityDeletionChannel& other) noexcept = delete;
     SceneEntityDeletionChannel& operator=(const SceneEntityDeletionChannel& other) noexcept = delete;
     SceneEntityDeletionChannel(SceneEntityDeletionChannel&& other) noexcept = default;
     SceneEntityDeletionChannel& operator=(SceneEntityDeletionChannel&& other) noexcept = default;
     ~SceneEntityDeletionChannel() = default;
   
   private:
     explicit SceneEntityDeletionChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class SceneEntityChannel {
   public:
     static FoxgloveResult<SceneEntityChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const SceneEntity& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     SceneEntityChannel(const SceneEntityChannel& other) noexcept = delete;
     SceneEntityChannel& operator=(const SceneEntityChannel& other) noexcept = delete;
     SceneEntityChannel(SceneEntityChannel&& other) noexcept = default;
     SceneEntityChannel& operator=(SceneEntityChannel&& other) noexcept = default;
     ~SceneEntityChannel() = default;
   
   private:
     explicit SceneEntityChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class SceneUpdateChannel {
   public:
     static FoxgloveResult<SceneUpdateChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const SceneUpdate& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     SceneUpdateChannel(const SceneUpdateChannel& other) noexcept = delete;
     SceneUpdateChannel& operator=(const SceneUpdateChannel& other) noexcept = delete;
     SceneUpdateChannel(SceneUpdateChannel&& other) noexcept = default;
     SceneUpdateChannel& operator=(SceneUpdateChannel&& other) noexcept = default;
     ~SceneUpdateChannel() = default;
   
   private:
     explicit SceneUpdateChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class ModelPrimitiveChannel {
   public:
     static FoxgloveResult<ModelPrimitiveChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const ModelPrimitive& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     ModelPrimitiveChannel(const ModelPrimitiveChannel& other) noexcept = delete;
     ModelPrimitiveChannel& operator=(const ModelPrimitiveChannel& other) noexcept = delete;
     ModelPrimitiveChannel(ModelPrimitiveChannel&& other) noexcept = default;
     ModelPrimitiveChannel& operator=(ModelPrimitiveChannel&& other) noexcept = default;
     ~ModelPrimitiveChannel() = default;
   
   private:
     explicit ModelPrimitiveChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class PackedElementFieldChannel {
   public:
     static FoxgloveResult<PackedElementFieldChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const PackedElementField& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     PackedElementFieldChannel(const PackedElementFieldChannel& other) noexcept = delete;
     PackedElementFieldChannel& operator=(const PackedElementFieldChannel& other) noexcept = delete;
     PackedElementFieldChannel(PackedElementFieldChannel&& other) noexcept = default;
     PackedElementFieldChannel& operator=(PackedElementFieldChannel&& other) noexcept = default;
     ~PackedElementFieldChannel() = default;
   
   private:
     explicit PackedElementFieldChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class Point2Channel {
   public:
     static FoxgloveResult<Point2Channel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const Point2& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     Point2Channel(const Point2Channel& other) noexcept = delete;
     Point2Channel& operator=(const Point2Channel& other) noexcept = delete;
     Point2Channel(Point2Channel&& other) noexcept = default;
     Point2Channel& operator=(Point2Channel&& other) noexcept = default;
     ~Point2Channel() = default;
   
   private:
     explicit Point2Channel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class Point3Channel {
   public:
     static FoxgloveResult<Point3Channel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const Point3& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     Point3Channel(const Point3Channel& other) noexcept = delete;
     Point3Channel& operator=(const Point3Channel& other) noexcept = delete;
     Point3Channel(Point3Channel&& other) noexcept = default;
     Point3Channel& operator=(Point3Channel&& other) noexcept = default;
     ~Point3Channel() = default;
   
   private:
     explicit Point3Channel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class PointCloudChannel {
   public:
     static FoxgloveResult<PointCloudChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const PointCloud& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     PointCloudChannel(const PointCloudChannel& other) noexcept = delete;
     PointCloudChannel& operator=(const PointCloudChannel& other) noexcept = delete;
     PointCloudChannel(PointCloudChannel&& other) noexcept = default;
     PointCloudChannel& operator=(PointCloudChannel&& other) noexcept = default;
     ~PointCloudChannel() = default;
   
   private:
     explicit PointCloudChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class PointsAnnotationChannel {
   public:
     static FoxgloveResult<PointsAnnotationChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const PointsAnnotation& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     PointsAnnotationChannel(const PointsAnnotationChannel& other) noexcept = delete;
     PointsAnnotationChannel& operator=(const PointsAnnotationChannel& other) noexcept = delete;
     PointsAnnotationChannel(PointsAnnotationChannel&& other) noexcept = default;
     PointsAnnotationChannel& operator=(PointsAnnotationChannel&& other) noexcept = default;
     ~PointsAnnotationChannel() = default;
   
   private:
     explicit PointsAnnotationChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class PoseChannel {
   public:
     static FoxgloveResult<PoseChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const Pose& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     PoseChannel(const PoseChannel& other) noexcept = delete;
     PoseChannel& operator=(const PoseChannel& other) noexcept = delete;
     PoseChannel(PoseChannel&& other) noexcept = default;
     PoseChannel& operator=(PoseChannel&& other) noexcept = default;
     ~PoseChannel() = default;
   
   private:
     explicit PoseChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class PoseInFrameChannel {
   public:
     static FoxgloveResult<PoseInFrameChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const PoseInFrame& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     PoseInFrameChannel(const PoseInFrameChannel& other) noexcept = delete;
     PoseInFrameChannel& operator=(const PoseInFrameChannel& other) noexcept = delete;
     PoseInFrameChannel(PoseInFrameChannel&& other) noexcept = default;
     PoseInFrameChannel& operator=(PoseInFrameChannel&& other) noexcept = default;
     ~PoseInFrameChannel() = default;
   
   private:
     explicit PoseInFrameChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class PosesInFrameChannel {
   public:
     static FoxgloveResult<PosesInFrameChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const PosesInFrame& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     PosesInFrameChannel(const PosesInFrameChannel& other) noexcept = delete;
     PosesInFrameChannel& operator=(const PosesInFrameChannel& other) noexcept = delete;
     PosesInFrameChannel(PosesInFrameChannel&& other) noexcept = default;
     PosesInFrameChannel& operator=(PosesInFrameChannel&& other) noexcept = default;
     ~PosesInFrameChannel() = default;
   
   private:
     explicit PosesInFrameChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class QuaternionChannel {
   public:
     static FoxgloveResult<QuaternionChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const Quaternion& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     QuaternionChannel(const QuaternionChannel& other) noexcept = delete;
     QuaternionChannel& operator=(const QuaternionChannel& other) noexcept = delete;
     QuaternionChannel(QuaternionChannel&& other) noexcept = default;
     QuaternionChannel& operator=(QuaternionChannel&& other) noexcept = default;
     ~QuaternionChannel() = default;
   
   private:
     explicit QuaternionChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class RawAudioChannel {
   public:
     static FoxgloveResult<RawAudioChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const RawAudio& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     RawAudioChannel(const RawAudioChannel& other) noexcept = delete;
     RawAudioChannel& operator=(const RawAudioChannel& other) noexcept = delete;
     RawAudioChannel(RawAudioChannel&& other) noexcept = default;
     RawAudioChannel& operator=(RawAudioChannel&& other) noexcept = default;
     ~RawAudioChannel() = default;
   
   private:
     explicit RawAudioChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class RawImageChannel {
   public:
     static FoxgloveResult<RawImageChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const RawImage& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     RawImageChannel(const RawImageChannel& other) noexcept = delete;
     RawImageChannel& operator=(const RawImageChannel& other) noexcept = delete;
     RawImageChannel(RawImageChannel&& other) noexcept = default;
     RawImageChannel& operator=(RawImageChannel&& other) noexcept = default;
     ~RawImageChannel() = default;
   
   private:
     explicit RawImageChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class SpherePrimitiveChannel {
   public:
     static FoxgloveResult<SpherePrimitiveChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const SpherePrimitive& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     SpherePrimitiveChannel(const SpherePrimitiveChannel& other) noexcept = delete;
     SpherePrimitiveChannel& operator=(const SpherePrimitiveChannel& other) noexcept = delete;
     SpherePrimitiveChannel(SpherePrimitiveChannel&& other) noexcept = default;
     SpherePrimitiveChannel& operator=(SpherePrimitiveChannel&& other) noexcept = default;
     ~SpherePrimitiveChannel() = default;
   
   private:
     explicit SpherePrimitiveChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class TextAnnotationChannel {
   public:
     static FoxgloveResult<TextAnnotationChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const TextAnnotation& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     TextAnnotationChannel(const TextAnnotationChannel& other) noexcept = delete;
     TextAnnotationChannel& operator=(const TextAnnotationChannel& other) noexcept = delete;
     TextAnnotationChannel(TextAnnotationChannel&& other) noexcept = default;
     TextAnnotationChannel& operator=(TextAnnotationChannel&& other) noexcept = default;
     ~TextAnnotationChannel() = default;
   
   private:
     explicit TextAnnotationChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class TextPrimitiveChannel {
   public:
     static FoxgloveResult<TextPrimitiveChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const TextPrimitive& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     TextPrimitiveChannel(const TextPrimitiveChannel& other) noexcept = delete;
     TextPrimitiveChannel& operator=(const TextPrimitiveChannel& other) noexcept = delete;
     TextPrimitiveChannel(TextPrimitiveChannel&& other) noexcept = default;
     TextPrimitiveChannel& operator=(TextPrimitiveChannel&& other) noexcept = default;
     ~TextPrimitiveChannel() = default;
   
   private:
     explicit TextPrimitiveChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class TriangleListPrimitiveChannel {
   public:
     static FoxgloveResult<TriangleListPrimitiveChannel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const TriangleListPrimitive& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     TriangleListPrimitiveChannel(const TriangleListPrimitiveChannel& other) noexcept = delete;
     TriangleListPrimitiveChannel& operator=(const TriangleListPrimitiveChannel& other
     ) noexcept = delete;
     TriangleListPrimitiveChannel(TriangleListPrimitiveChannel&& other) noexcept = default;
     TriangleListPrimitiveChannel& operator=(TriangleListPrimitiveChannel&& other) noexcept = default;
     ~TriangleListPrimitiveChannel() = default;
   
   private:
     explicit TriangleListPrimitiveChannel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class Vector2Channel {
   public:
     static FoxgloveResult<Vector2Channel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const Vector2& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     Vector2Channel(const Vector2Channel& other) noexcept = delete;
     Vector2Channel& operator=(const Vector2Channel& other) noexcept = delete;
     Vector2Channel(Vector2Channel&& other) noexcept = default;
     Vector2Channel& operator=(Vector2Channel&& other) noexcept = default;
     ~Vector2Channel() = default;
   
   private:
     explicit Vector2Channel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   class Vector3Channel {
   public:
     static FoxgloveResult<Vector3Channel> create(
       const std::string_view& topic, const Context& context = Context()
     );
   
     FoxgloveError log(
       const Vector3& msg, std::optional<uint64_t> log_time = std::nullopt,
       std::optional<uint64_t> sink_id = std::nullopt
     ) noexcept;
   
     void close() noexcept;
   
     [[nodiscard]] uint64_t id() const noexcept;
   
     [[nodiscard]] bool has_sinks() const noexcept;
   
     Vector3Channel(const Vector3Channel& other) noexcept = delete;
     Vector3Channel& operator=(const Vector3Channel& other) noexcept = delete;
     Vector3Channel(Vector3Channel&& other) noexcept = default;
     Vector3Channel& operator=(Vector3Channel&& other) noexcept = default;
     ~Vector3Channel() = default;
   
   private:
     explicit Vector3Channel(ChannelUniquePtr&& channel)
         : impl_(std::move(channel)) {}
   
     ChannelUniquePtr impl_;
   };
   
   #endif
   
   }  // namespace foxglove::schemas
