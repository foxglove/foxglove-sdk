// Generated by https://github.com/foxglove/foxglove-sdk

#pragma once

#include <array>
#include <cstdint>
#include <string>
#include <type_traits>
#include <vector>

#include <foxglove/time.hpp>

namespace foxglove::schemas {

/// A vector in 3D space that represents a direction only
struct Vector3 {
  /// x coordinate length
  double x = 1;

  /// y coordinate length
  double y = 1;

  /// z coordinate length
  double z = 1;
};

/// A [quaternion](https://eater.net/quaternions) representing a rotation in 3D space
struct Quaternion {
  /// x value
  double x = 0;

  /// y value
  double y = 0;

  /// z value
  double z = 0;

  /// w value
  double w = 1;
};

/// A position and orientation for an object or reference frame in 3D space
struct Pose {
  /// Point denoting position in 3D space
  Vector3 position;

  /// Quaternion denoting orientation in 3D space
  Quaternion orientation;
};

/// A color in RGBA format
struct Color {
  /// Red value between 0 and 1
  double r = 1;

  /// Green value between 0 and 1
  double g = 1;

  /// Blue value between 0 and 1
  double b = 1;

  /// Alpha value between 0 and 1
  double a = 1;
};

/// A primitive representing an arrow
struct ArrowPrimitive {
  /// Position of the arrow's tail and orientation of the arrow. Identity orientation means the arrow points in the +x direction.
  Pose pose;

  /// Length of the arrow shaft
  double shaft_length = 0;

  /// Diameter of the arrow shaft
  double shaft_diameter = 0;

  /// Length of the arrow head
  double head_length = 0;

  /// Diameter of the arrow head
  double head_diameter = 0;

  /// Color of the arrow
  Color color;
};

/// Camera calibration parameters
struct CameraCalibration {
  /// Timestamp of calibration data
  foxglove::Timestamp timestamp;

  /// Frame of reference for the camera. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
  std::string frame_id;

  /// Image width
  uint32_t width = 0;

  /// Image height
  uint32_t height = 0;

  /// Name of distortion model
  /// 
  /// Supported parameters: `plumb_bob` (k1, k2, p1, p2, k3) and `rational_polynomial` (k1, k2, p1, p2, k3, k4, k5, k6). Distortion models are based on [OpenCV's](https://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html) [pinhole camera model](https://en.wikipedia.org/wiki/Distortion_%28optics%29#Software_correction). This is the same [implementation used by ROS](http://docs.ros.org/en/diamondback/api/image_geometry/html/c++/pinhole__camera__model_8cpp_source.html)
  std::string distortion_model;

  /// Distortion parameters
  std::vector<double> D;

  /// Intrinsic camera matrix (3x3 row-major matrix)
  /// 
  /// A 3x3 row-major matrix for the raw (distorted) image.
  /// 
  /// Projects 3D points in the camera coordinate frame to 2D pixel coordinates using the focal lengths (fx, fy) and principal point (cx, cy).
  /// 
  /// ```
  ///     [fx  0 cx]
  /// K = [ 0 fy cy]
  ///     [ 0  0  1]
  /// ```
  /// 
  std::array<double, 9> K;

  /// Rectification matrix (stereo cameras only, 3x3 row-major matrix)
  /// 
  /// A rotation matrix aligning the camera coordinate system to the ideal stereo image plane so that epipolar lines in both stereo images are parallel.
  std::array<double, 9> R;

  /// Projection/camera matrix (3x4 row-major matrix)
  /// 
  /// ```
  ///     [fx'  0  cx' Tx]
  /// P = [ 0  fy' cy' Ty]
  ///     [ 0   0   1   0]
  /// ```
  /// 
  /// By convention, this matrix specifies the intrinsic (camera) matrix of the processed (rectified) image. That is, the left 3x3 portion is the normal camera intrinsic matrix for the rectified image.
  /// 
  /// It projects 3D points in the camera coordinate frame to 2D pixel coordinates using the focal lengths (fx', fy') and principal point (cx', cy') - these may differ from the values in K.
  /// 
  /// For monocular cameras, Tx = Ty = 0. Normally, monocular cameras will also have R = the identity and P[1:3,1:3] = K.
  /// 
  /// For a stereo pair, the fourth column [Tx Ty 0]' is related to the position of the optical center of the second camera in the first camera's frame. We assume Tz = 0 so both cameras are in the same stereo image plane. The first camera always has Tx = Ty = 0. For the right (second) camera of a horizontal stereo pair, Ty = 0 and Tx = -fx' * B, where B is the baseline between the cameras.
  /// 
  /// Given a 3D point [X Y Z]', the projection (x, y) of the point onto the rectified image is given by:
  /// 
  /// ```
  /// [u v w]' = P * [X Y Z 1]'
  ///        x = u / w
  ///        y = v / w
  /// ```
  /// 
  /// This holds for both images of a stereo pair.
  /// 
  std::array<double, 12> P;
};

/// A point representing a position in 2D space
struct Point2 {
  /// x coordinate position
  double x = 0;

  /// y coordinate position
  double y = 0;
};

/// A circle annotation on a 2D image
struct CircleAnnotation {
  /// Timestamp of circle
  foxglove::Timestamp timestamp;

  /// Center of the circle in 2D image coordinates (pixels).
  /// The coordinate uses the top-left corner of the top-left pixel of the image as the origin.
  Point2 position;

  /// Circle diameter in pixels
  double diameter = 0;

  /// Line thickness in pixels
  double thickness = 0;

  /// Fill color
  Color fill_color;

  /// Outline color
  Color outline_color;
};

/// A compressed image
struct CompressedImage {
  /// Timestamp of image
  foxglove::Timestamp timestamp;

  /// Frame of reference for the image. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
  std::string frame_id;

  /// Compressed image data
  std::vector<std::byte> data;

  /// Image format
  /// 
  /// Supported values: image media types supported by Chrome, such as `webp`, `jpeg`, `png`
  std::string format;
};

/// A single frame of a compressed video bitstream
struct CompressedVideo {
  /// Timestamp of video frame
  foxglove::Timestamp timestamp;

  /// Frame of reference for the video.
  /// 
  /// The origin of the frame is the optical center of the camera. +x points to the right in the video, +y points down, and +z points into the plane of the video.
  std::string frame_id;

  /// Compressed video frame data.
  /// 
  /// For packet-based video codecs this data must begin and end on packet boundaries (no partial packets), and must contain enough video packets to decode exactly one image (either a keyframe or delta frame). Note: Foxglove does not support video streams that include B frames because they require lookahead.
  /// 
  /// Specifically, the requirements for different `format` values are:
  /// 
  /// - `h264`
  ///   - Use Annex B formatted data
  ///   - Each CompressedVideo message should contain enough NAL units to decode exactly one video frame
  ///   - Each message containing a key frame (IDR) must also include a SPS NAL unit
  /// 
  /// - `h265` (HEVC)
  ///   - Use Annex B formatted data
  ///   - Each CompressedVideo message should contain enough NAL units to decode exactly one video frame
  ///   - Each message containing a key frame (IRAP) must also include relevant VPS/SPS/PPS NAL units
  /// 
  /// - `vp9`
  ///   - Each CompressedVideo message should contain exactly one video frame
  /// 
  /// - `av1`
  ///   - Use the "Low overhead bitstream format" (section 5.2)
  ///   - Each CompressedVideo message should contain enough OBUs to decode exactly one video frame
  ///   - Each message containing a key frame must also include a Sequence Header OBU
  std::vector<std::byte> data;

  /// Video format.
  /// 
  /// Supported values: `h264`, `h265`, `vp9`, `av1`.
  /// 
  /// Note: compressed video support is subject to hardware limitations and patent licensing, so not all encodings may be supported on all platforms. See more about [H.265 support](https://caniuse.com/hevc), [VP9 support](https://caniuse.com/webm), and [AV1 support](https://caniuse.com/av1).
  std::string format;
};

/// A primitive representing a cylinder, elliptic cylinder, or truncated cone
struct CylinderPrimitive {
  /// Position of the center of the cylinder and orientation of the cylinder. The flat face(s) are perpendicular to the z-axis.
  Pose pose;

  /// Size of the cylinder's bounding box
  Vector3 size;

  /// 0-1, ratio of the diameter of the cylinder's bottom face (min z) to the bottom of the bounding box
  double bottom_scale = 0;

  /// 0-1, ratio of the diameter of the cylinder's top face (max z) to the top of the bounding box
  double top_scale = 0;

  /// Color of the cylinder
  Color color;
};

/// A primitive representing a cube or rectangular prism
struct CubePrimitive {
  /// Position of the center of the cube and orientation of the cube
  Pose pose;

  /// Size of the cube along each axis
  Vector3 size;

  /// Color of the cube
  Color color;
};

/// A transform between two reference frames in 3D space
struct FrameTransform {
  /// Timestamp of transform
  foxglove::Timestamp timestamp;

  /// Name of the parent frame
  std::string parent_frame_id;

  /// Name of the child frame
  std::string child_frame_id;

  /// Translation component of the transform
  Vector3 translation;

  /// Rotation component of the transform
  Quaternion rotation;
};

/// An array of FrameTransform messages
struct FrameTransforms {
  /// Array of transforms
  std::vector<FrameTransform> transforms;
};

/// GeoJSON data for annotating maps
struct GeoJSON {
  /// GeoJSON data encoded as a UTF-8 string
  std::string geojson;
};

/// A vector in 2D space that represents a direction only
struct Vector2 {
  /// x coordinate length
  double x = 1;

  /// y coordinate length
  double y = 1;
};

/// A field present within each element in a byte array of packed elements.
struct PackedElementField {
  /// Numeric type
  enum class NumericType : uint8_t {
    UNKNOWN = 0,
    UINT8 = 1,
    INT8 = 2,
    UINT16 = 3,
    INT16 = 4,
    UINT32 = 5,
    INT32 = 6,
    FLOAT32 = 7,
    FLOAT64 = 8,
  };
  /// Name of the field
  std::string name;

  /// Byte offset from start of data buffer
  uint32_t offset = 0;

  /// Type of data in the field. Integers are stored using little-endian byte order.
  NumericType type;
};

/// A 2D grid of data
struct Grid {
  /// Timestamp of grid
  foxglove::Timestamp timestamp;

  /// Frame of reference
  std::string frame_id;

  /// Origin of grid's corner relative to frame of reference; grid is positioned in the x-y plane relative to this origin
  Pose pose;

  /// Number of grid columns
  uint32_t column_count = 0;

  /// Size of single grid cell along x and y axes, relative to `pose`
  Vector2 cell_size;

  /// Number of bytes between rows in `data`
  uint32_t row_stride = 0;

  /// Number of bytes between cells within a row in `data`
  uint32_t cell_stride = 0;

  /// Fields in `data`. `red`, `green`, `blue`, and `alpha` are optional for customizing the grid's color.
  std::vector<PackedElementField> fields;

  /// Grid cell data, interpreted using `fields`, in row-major (y-major) order
  std::vector<std::byte> data;
};

/// An array of points on a 2D image
struct PointsAnnotation {
  /// Type of points annotation
  enum class PointsAnnotationType : uint8_t {
    UNKNOWN = 0,
    /// Individual points: 0, 1, 2, ...
    POINTS = 1,
    /// Closed polygon: 0-1, 1-2, ..., (n-1)-n, n-0
    LINE_LOOP = 2,
    /// Connected line segments: 0-1, 1-2, ..., (n-1)-n
    LINE_STRIP = 3,
    /// Individual line segments: 0-1, 2-3, 4-5, ...
    LINE_LIST = 4,
  };
  /// Timestamp of annotation
  foxglove::Timestamp timestamp;

  /// Type of points annotation to draw
  PointsAnnotationType type;

  /// Points in 2D image coordinates (pixels).
  /// These coordinates use the top-left corner of the top-left pixel of the image as the origin.
  std::vector<Point2> points;

  /// Outline color
  Color outline_color;

  /// Per-point colors, if `type` is `POINTS`, or per-segment stroke colors, if `type` is `LINE_LIST`, `LINE_STRIP` or `LINE_LOOP`.
  std::vector<Color> outline_colors;

  /// Fill color
  Color fill_color;

  /// Stroke thickness in pixels
  double thickness = 0;
};

/// A text label on a 2D image
struct TextAnnotation {
  /// Timestamp of annotation
  foxglove::Timestamp timestamp;

  /// Bottom-left origin of the text label in 2D image coordinates (pixels).
  /// The coordinate uses the top-left corner of the top-left pixel of the image as the origin.
  Point2 position;

  /// Text to display
  std::string text;

  /// Font size in pixels
  double font_size = 12;

  /// Text color
  Color text_color;

  /// Background fill color
  Color background_color;
};

/// Array of annotations for a 2D image
struct ImageAnnotations {
  /// Circle annotations
  std::vector<CircleAnnotation> circles;

  /// Points annotations
  std::vector<PointsAnnotation> points;

  /// Text annotations
  std::vector<TextAnnotation> texts;
};

/// A key with its associated value
struct KeyValuePair {
  /// Key
  std::string key;

  /// Value
  std::string value;
};

/// A single scan from a planar laser range-finder
struct LaserScan {
  /// Timestamp of scan
  foxglove::Timestamp timestamp;

  /// Frame of reference
  std::string frame_id;

  /// Origin of scan relative to frame of reference; points are positioned in the x-y plane relative to this origin; angles are interpreted as counterclockwise rotations around the z axis with 0 rad being in the +x direction
  Pose pose;

  /// Bearing of first point, in radians
  double start_angle = 0;

  /// Bearing of last point, in radians
  double end_angle = 0;

  /// Distance of detections from origin; assumed to be at equally-spaced angles between `start_angle` and `end_angle`
  std::vector<double> ranges;

  /// Intensity of detections
  std::vector<double> intensities;
};

/// A point representing a position in 3D space
struct Point3 {
  /// x coordinate position
  double x = 0;

  /// y coordinate position
  double y = 0;

  /// z coordinate position
  double z = 0;
};

/// A primitive representing a series of points connected by lines
struct LinePrimitive {
  /// An enumeration indicating how input points should be interpreted to create lines
  enum class LineType : uint8_t {
    /// Connected line segments: 0-1, 1-2, ..., (n-1)-n
    LINE_STRIP = 0,
    /// Closed polygon: 0-1, 1-2, ..., (n-1)-n, n-0
    LINE_LOOP = 1,
    /// Individual line segments: 0-1, 2-3, 4-5, ...
    LINE_LIST = 2,
  };
  /// Drawing primitive to use for lines
  LineType type;

  /// Origin of lines relative to reference frame
  Pose pose;

  /// Line thickness
  double thickness = 0;

  /// Indicates whether `thickness` is a fixed size in screen pixels (true), or specified in world coordinates and scales with distance from the camera (false)
  bool scale_invariant = false;

  /// Points along the line
  std::vector<Point3> points;

  /// Solid color to use for the whole line. One of `color` or `colors` must be provided.
  Color color;

  /// Per-point colors (if specified, must have the same length as `points`). One of `color` or `colors` must be provided.
  std::vector<Color> colors;

  /// Indices into the `points` and `colors` attribute arrays, which can be used to avoid duplicating attribute data.
  /// 
  /// If omitted or empty, indexing will not be used. This default behavior is equivalent to specifying [0, 1, ..., N-1] for the indices (where N is the number of `points` provided).
  std::vector<uint32_t> indices;
};

/// A navigation satellite fix for any Global Navigation Satellite System
struct LocationFix {
  /// Type of position covariance
  enum class PositionCovarianceType : uint8_t {
    UNKNOWN = 0,
    APPROXIMATED = 1,
    DIAGONAL_KNOWN = 2,
    KNOWN = 3,
  };
  /// Timestamp of the message
  foxglove::Timestamp timestamp;

  /// Frame for the sensor. Latitude and longitude readings are at the origin of the frame.
  std::string frame_id;

  /// Latitude in degrees
  double latitude = 0;

  /// Longitude in degrees
  double longitude = 0;

  /// Altitude in meters
  double altitude = 0;

  /// Position covariance (m^2) defined relative to a tangential plane through the reported position. The components are East, North, and Up (ENU), in row-major order.
  std::array<double, 9> position_covariance;

  /// If `position_covariance` is available, `position_covariance_type` must be set to indicate the type of covariance.
  PositionCovarianceType position_covariance_type;
};

/// A log message
struct Log {
  /// Log level
  enum class LogLevel : uint8_t {
    UNKNOWN = 0,
    DEBUG = 1,
    INFO = 2,
    WARNING = 3,
    ERROR = 4,
    FATAL = 5,
  };
  /// Timestamp of log message
  foxglove::Timestamp timestamp;

  /// Log level
  LogLevel level;

  /// Log message
  std::string message;

  /// Process or node name
  std::string name;

  /// Filename
  std::string file;

  /// Line number in the file
  uint32_t line = 0;
};

/// Command to remove previously published entities
struct SceneEntityDeletion {
  /// An enumeration indicating which entities should match a SceneEntityDeletion command
  enum class SceneEntityDeletionType : uint8_t {
    /// Delete the existing entity on the same topic that has the provided `id`
    MATCHING_ID = 0,
    /// Delete all existing entities on the same topic
    ALL = 1,
  };
  /// Timestamp of the deletion. Only matching entities earlier than this timestamp will be deleted.
  foxglove::Timestamp timestamp;

  /// Type of deletion action to perform
  SceneEntityDeletionType type;

  /// Identifier which must match if `type` is `MATCHING_ID`.
  std::string id;
};

/// A primitive representing a sphere or ellipsoid
struct SpherePrimitive {
  /// Position of the center of the sphere and orientation of the sphere
  Pose pose;

  /// Size (diameter) of the sphere along each axis
  Vector3 size;

  /// Color of the sphere
  Color color;
};

/// A primitive representing a set of triangles or a surface tiled by triangles
struct TriangleListPrimitive {
  /// Origin of triangles relative to reference frame
  Pose pose;

  /// Vertices to use for triangles, interpreted as a list of triples (0-1-2, 3-4-5, ...)
  std::vector<Point3> points;

  /// Solid color to use for the whole shape. One of `color` or `colors` must be provided.
  Color color;

  /// Per-vertex colors (if specified, must have the same length as `points`). One of `color` or `colors` must be provided.
  std::vector<Color> colors;

  /// Indices into the `points` and `colors` attribute arrays, which can be used to avoid duplicating attribute data.
  /// 
  /// If omitted or empty, indexing will not be used. This default behavior is equivalent to specifying [0, 1, ..., N-1] for the indices (where N is the number of `points` provided).
  std::vector<uint32_t> indices;
};

/// A primitive representing a text label
struct TextPrimitive {
  /// Position of the center of the text box and orientation of the text. Identity orientation means the text is oriented in the xy-plane and flows from -x to +x.
  Pose pose;

  /// Whether the text should respect `pose.orientation` (false) or always face the camera (true)
  bool billboard = false;

  /// Font size (height of one line of text)
  double font_size = 0;

  /// Indicates whether `font_size` is a fixed size in screen pixels (true), or specified in world coordinates and scales with distance from the camera (false)
  bool scale_invariant = false;

  /// Color of the text
  Color color;

  /// Text
  std::string text;
};

/// A primitive representing a 3D model file loaded from an external URL or embedded data
struct ModelPrimitive {
  /// Origin of model relative to reference frame
  Pose pose;

  /// Scale factor to apply to the model along each axis
  Vector3 scale;

  /// Solid color to use for the whole model if `override_color` is true.
  Color color;

  /// Whether to use the color specified in `color` instead of any materials embedded in the original model.
  bool override_color = false;

  /// URL pointing to model file. One of `url` or `data` should be provided.
  std::string url;

  /// [Media type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) of embedded model (e.g. `model/gltf-binary`). Required if `data` is provided instead of `url`. Overrides the inferred media type if `url` is provided.
  std::string media_type;

  /// Embedded model. One of `url` or `data` should be provided. If `data` is provided, `media_type` must be set to indicate the type of the data.
  std::vector<std::byte> data;
};

/// A visual element in a 3D scene. An entity may be composed of multiple primitives which all share the same frame of reference.
struct SceneEntity {
  /// Timestamp of the entity
  foxglove::Timestamp timestamp;

  /// Frame of reference
  std::string frame_id;

  /// Identifier for the entity. A entity will replace any prior entity on the same topic with the same `id`.
  std::string id;

  /// Length of time (relative to `timestamp`) after which the entity should be automatically removed. Zero value indicates the entity should remain visible until it is replaced or deleted.
  foxglove::Duration lifetime;

  /// Whether the entity should keep its location in the fixed frame (false) or follow the frame specified in `frame_id` as it moves relative to the fixed frame (true)
  bool frame_locked = false;

  /// Additional user-provided metadata associated with the entity. Keys must be unique.
  std::vector<KeyValuePair> metadata;

  /// Arrow primitives
  std::vector<ArrowPrimitive> arrows;

  /// Cube primitives
  std::vector<CubePrimitive> cubes;

  /// Sphere primitives
  std::vector<SpherePrimitive> spheres;

  /// Cylinder primitives
  std::vector<CylinderPrimitive> cylinders;

  /// Line primitives
  std::vector<LinePrimitive> lines;

  /// Triangle list primitives
  std::vector<TriangleListPrimitive> triangles;

  /// Text primitives
  std::vector<TextPrimitive> texts;

  /// Model primitives
  std::vector<ModelPrimitive> models;
};

/// An update to the entities displayed in a 3D scene
struct SceneUpdate {
  /// Scene entities to delete
  std::vector<SceneEntityDeletion> deletions;

  /// Scene entities to add or replace
  std::vector<SceneEntity> entities;
};

/// A collection of N-dimensional points, which may contain additional fields with information like normals, intensity, etc.
struct PointCloud {
  /// Timestamp of point cloud
  foxglove::Timestamp timestamp;

  /// Frame of reference
  std::string frame_id;

  /// The origin of the point cloud relative to the frame of reference
  Pose pose;

  /// Number of bytes between points in the `data`
  uint32_t point_stride = 0;

  /// Fields in `data`. At least 2 coordinate fields from `x`, `y`, and `z` are required for each point's position; `red`, `green`, `blue`, and `alpha` are optional for customizing each point's color.
  std::vector<PackedElementField> fields;

  /// Point data, interpreted using `fields`
  std::vector<std::byte> data;
};

/// A timestamped pose for an object or reference frame in 3D space
struct PoseInFrame {
  /// Timestamp of pose
  foxglove::Timestamp timestamp;

  /// Frame of reference for pose position and orientation
  std::string frame_id;

  /// Pose in 3D space
  Pose pose;
};

/// An array of timestamped poses for an object or reference frame in 3D space
struct PosesInFrame {
  /// Timestamp of pose
  foxglove::Timestamp timestamp;

  /// Frame of reference for pose position and orientation
  std::string frame_id;

  /// Poses in 3D space
  std::vector<Pose> poses;
};

/// A raw image
struct RawImage {
  /// Timestamp of image
  foxglove::Timestamp timestamp;

  /// Frame of reference for the image. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
  std::string frame_id;

  /// Image width
  uint32_t width = 0;

  /// Image height
  uint32_t height = 0;

  /// Encoding of the raw image data
  /// 
  /// Supported values: `8UC1`, `8UC3`, `16UC1` (little endian), `32FC1` (little endian), `bayer_bggr8`, `bayer_gbrg8`, `bayer_grbg8`, `bayer_rggb8`, `bgr8`, `bgra8`, `mono8`, `mono16`, `rgb8`, `rgba8`, `uyvy` or `yuv422`, `yuyv` or `yuv422_yuy2`
  std::string encoding;

  /// Byte length of a single row
  uint32_t step = 0;

  /// Raw image data
  std::vector<std::byte> data;
};

} // namespace foxglove::schemas

namespace foxglove::internal {

template<class T>
struct IsBuiltinSchema : std::false_type {};

template<>
struct IsBuiltinSchema<foxglove::schemas::ArrowPrimitive> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::CameraCalibration> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::CircleAnnotation> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::Color> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::CompressedImage> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::CompressedVideo> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::CylinderPrimitive> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::CubePrimitive> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::FrameTransform> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::FrameTransforms> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::GeoJSON> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::Grid> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::ImageAnnotations> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::KeyValuePair> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::LaserScan> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::LinePrimitive> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::LocationFix> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::Log> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::SceneEntityDeletion> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::SceneEntity> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::SceneUpdate> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::ModelPrimitive> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::PackedElementField> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::Point2> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::Point3> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::PointCloud> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::PointsAnnotation> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::Pose> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::PoseInFrame> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::PosesInFrame> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::Quaternion> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::RawImage> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::SpherePrimitive> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::TextAnnotation> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::TextPrimitive> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::TriangleListPrimitive> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::Vector2> : std::true_type {};
template<>
struct IsBuiltinSchema<foxglove::schemas::Vector3> : std::true_type {};

} // namespace foxglove::internal
