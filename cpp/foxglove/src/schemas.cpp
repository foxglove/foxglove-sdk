// Generated by https://github.com/foxglove/foxglove-sdk

#include <foxglove-c/foxglove-c.h>

#include <foxglove/error.hpp>
#include <foxglove/schemas.hpp>

#include <optional>

namespace foxglove::internal {

using namespace foxglove;
using namespace foxglove::schemas;

template<>
struct BuiltinSchema<CameraCalibration> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const CameraCalibration& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_camera_calibration cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_camera_calibration(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<CircleAnnotation> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const CircleAnnotation& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_circle_annotation cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_circle_annotation(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<Color> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const Color& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_color cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_color(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<CompressedImage> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const CompressedImage& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_compressed_image cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_compressed_image(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<CompressedVideo> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const CompressedVideo& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_compressed_video cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_compressed_video(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<FrameTransform> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const FrameTransform& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_frame_transform cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_frame_transform(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<FrameTransforms> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const FrameTransforms& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_frame_transforms cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_frame_transforms(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<GeoJSON> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const GeoJSON& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_geo_json cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_geo_json(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<Grid> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const Grid& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_grid cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_grid(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<ImageAnnotations> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const ImageAnnotations& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_image_annotations cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_image_annotations(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<KeyValuePair> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const KeyValuePair& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_key_value_pair cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_key_value_pair(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<LaserScan> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const LaserScan& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_laser_scan cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_laser_scan(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<LocationFix> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const LocationFix& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_location_fix cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_location_fix(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<Log> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const Log& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_log cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_log(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<PackedElementField> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const PackedElementField& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_packed_element_field cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_packed_element_field(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<Point2> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const Point2& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_point2 cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_point2(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<Point3> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const Point3& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_point3 cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_point3(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<PointCloud> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const PointCloud& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_point_cloud cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_point_cloud(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<PointsAnnotation> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const PointsAnnotation& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_points_annotation cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_points_annotation(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<Pose> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const Pose& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_pose cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_pose(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<PoseInFrame> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const PoseInFrame& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_pose_in_frame cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_pose_in_frame(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<PosesInFrame> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const PosesInFrame& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_poses_in_frame cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_poses_in_frame(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<Quaternion> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const Quaternion& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_quaternion cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_quaternion(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<RawAudio> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const RawAudio& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_raw_audio cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_raw_audio(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<RawImage> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const RawImage& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_raw_image cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_raw_image(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<SceneEntity> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const SceneEntity& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_scene_entity cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_scene_entity(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<SceneEntityDeletion> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const SceneEntityDeletion& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_scene_entity_deletion cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_scene_entity_deletion(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<SceneUpdate> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const SceneUpdate& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_scene_update cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_scene_update(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<TextAnnotation> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const TextAnnotation& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_text_annotation cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_text_annotation(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<Vector2> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const Vector2& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_vector2 cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_vector2(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};
template<>
struct BuiltinSchema<Vector3> : std::true_type {
  inline FoxgloveError log_to(foxglove_channel * const channel, const Vector3& msg, std::optional<uint64_t> logTime = std::nullopt) {
    foxglove_vector3 cMsg;
    // TODO
    return FoxgloveError(foxglove_channel_log_vector3(channel, &cMsg, logTime ? &*logTime : nullptr));
  }
};

} // namespace foxglove::schemas
