import { FoxgloveMessageSchema, FoxglovePrimitive } from "./types";

function primitiveToRust(type: Exclude<FoxglovePrimitive, "string" | "bytes">) {
  switch (type) {
    case "uint32":
      return "u32";
    case "boolean":
      return "bool";
    case "float64":
      return "f64";
    case "time":
      return "Timestamp";
    case "duration":
      return "Duration";
  }
}

function formatComment(comment: string) {
  return comment
    .split("\n")
    .map((line) => `/// ${line}`)
    .join("\n");
}

function escapeId(id: string) {
  if (id === "type") {
    return `r#${id}`;
  }
  return id;
}

export function generateRustTypes(schemas: readonly FoxgloveMessageSchema[]): string {
  const schemaStructs = schemas.map(
    (schema) => `\
${formatComment(schema.description)}
#[repr(C)]
pub struct ${schema.name} {
  ${schema.fields
    .flatMap((field) => {
      const comment = formatComment(field.description);
      if (field.array !== undefined) {
        return [
          // `${comment}\npub ${escapeId(field.name)}: !`,
          `${comment}\n/*TODO*/\n  pub ${escapeId(field.name)}_count: usize`,
        ];
      }
      switch (field.type.type) {
        case "primitive":
          if (field.type.name === "string") {
            return [
              `${comment}\npub ${escapeId(field.name)}: *const c_char`,
              `pub ${field.name}_len: usize`,
            ];
          } else if (field.type.name === "bytes") {
            return [
              `${comment}\npub ${escapeId(field.name)}: *const c_void`,
              `pub ${field.name}_len: usize`,
            ];
          }
          return `${comment}\npub ${escapeId(field.name)}: ${primitiveToRust(field.type.name)}`;
        case "enum":
          return `${comment}\npub ${escapeId(field.name)}: i32/*TODO*/`;
        case "nested":
          return `${comment}\npub ${escapeId(field.name)}: *const ${field.type.schema.name}`;
      }
    })
    .join(",\n  ")}
}

impl From<&${schema.name}> for foxglove::schemas::${schema.name.replace("JSON", "Json")} {
  fn from(msg: &${schema.name}) -> Self {
    Self {
      ${schema.fields
        .map((field) => {
          const srcName = escapeId(field.name);
          const dstName = escapeId(field.name).toLowerCase();
          if (field.array !== undefined) {
            return `${dstName}: todo!("arrays")`;
          }
          switch (field.type.type) {
            case "primitive":
              if (field.type.name === "string") {
                return `${dstName}: std::str::from_utf8(unsafe { std::slice::from_raw_parts(msg.${srcName} as *const u8, msg.${field.name}_len) }).unwrap().to_string()`;
              } else if (field.type.name === "bytes") {
                return `${dstName}: unsafe { std::slice::from_raw_parts(msg.${srcName}, msg.${field.name}_len) }`;
              } else if (field.type.name === "time" || field.type.name === "duration") {
                return `${dstName}: Some(msg.${srcName}.into())`;
              }
              return `${dstName}: msg.${srcName}`;
            case "enum":
              return `${dstName}: todo!()`;
            case "nested":
              return `${dstName}: Some(unsafe { &*msg.${srcName} }.into())`;
          }
        })
        .join(",      \n")}
    }
  }
}
`,
  );
  const outputSections = [
    `// Generated by https://github.com/foxglove/foxglove-sdk`,

    `use std::ffi::{c_char, c_void};`,

    [
      "#[repr(u8)]",
      "pub enum FoxgloveBuiltinSchema {",
      ...schemas.map((schema) => `  ${schema.name},`),
      "}",
    ].join("\n"),

    [
      "pub enum FoxgloveChannel {",
      ...schemas.map(
        (schema) =>
          `  ${schema.name}(foxglove::Channel<foxglove::schemas::${schema.name.replace("JSON", "Json")}>),`,
      ),
      "}",
    ].join("\n"),

    `\
/// A timestamp, represented as an offset from a user-defined epoch.
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct Timestamp {
    /// Seconds since epoch.
    pub sec: u32,
    /// Additional nanoseconds since epoch.
    pub nsec: u32,
}

impl From<Timestamp> for foxglove::schemas::Timestamp {
  fn from(other: Timestamp) -> Self {
    Self::new(other.sec, other.nsec)
  }
}`,

    `\
/// A signed, fixed-length span of time.
///
/// The duration is represented by a count of seconds (which may be negative), and a count of
/// fractional seconds at nanosecond resolution (which are always positive).
#[repr(C)]
pub struct Duration {
    /// Seconds offset.
    sec: i32,
    /// Nanoseconds offset in the positive direction.
    nsec: u32,
}

impl From<Duration> for foxglove::schemas::Duration {
  fn from(other: Duration) -> Self {
    Self::new(other.sec, other.nsec)
  }
}`,

    ...schemaStructs,

    `\
impl FoxgloveChannel {
  pub fn id(&self) -> foxglove::ChannelId {
    match self {
${schemas
  .map(
    (schema) => `\
      FoxgloveChannel::${schema.name}(ch) => ch.id(),`,
  )
  .join("\n")}
    }
  }

  /// # Safety
  /// \`msg\` must be a valid pointer to the same message schema this channel was created with.
  pub unsafe fn log_with_meta(&self, msg: *const core::ffi::c_void, meta: foxglove::PartialMetadata) {
    match self {
${schemas
  .map(
    (schema) => `\
      FoxgloveChannel::${schema.name}(ch) => {
        let msg = unsafe { &*(msg as *const self::${schema.name}) };
        ch.log_with_meta(&msg.into(), meta)
      },`,
  )
  .join("\n")}
    }
  }
}
`,

    `\
/// Build a strongly-typed Channel and turn it into a type-erased FoxgloveChannel.
pub(crate) fn build_channel_with_schema(builder: foxglove::ChannelBuilder, schema: FoxgloveBuiltinSchema) -> Result<FoxgloveChannel, foxglove::FoxgloveError> {
  match schema {
${schemas
  .map(
    (schema) =>
      `    FoxgloveBuiltinSchema::${schema.name} => builder.build().map(FoxgloveChannel::${schema.name}),`,
  )
  .join("\n")}
  }
}`,
  ].filter(Boolean);

  return outputSections.join("\n\n") + "\n";
}
