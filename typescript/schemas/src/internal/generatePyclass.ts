import {
  FoxgloveEnumSchema,
  FoxgloveMessageField,
  FoxgloveMessageSchema,
  FoxglovePrimitive,
  FoxgloveSchema,
} from "./types";

export function generatePrelude() {
  const docs = [
    `//! Definitions for well-known Foxglove schemas`,
    `//! Generated by https://github.com/foxglove/schemas`,
  ];

  const imports = ["use prost_types;", "use pyo3::prelude::*;"];

  const outputSections = [docs.join("\n"), imports.join("\n")];

  return outputSections.join("\n") + "\n\n";
}

export function generatePyclass(schema: FoxgloveSchema): string {
  return isMessageSchema(schema) ? generateMessageClass(schema) : generateEnumClass(schema);
}

function descriptionComments(str: string, opts: { indent?: number } = {}): string {
  const ws = " ".repeat(opts.indent ?? 0);
  return str
    .split("\n")
    .map((line) => `${ws}/// ${line}`)
    .join("\n");
}

function generateMessageClass(schema: FoxgloveMessageSchema): string {
  const schemaFields = Array.from(schema.fields).map((field) => ({
    fieldName: safeName(field.name),
    argName: safeName(field.name),
    description: descriptionComments(field.description, { indent: 4 }),
    field,
  }));

  const struct = [
    descriptionComments(schema.description),
    "#[pyclass]",
    "#[derive(Clone)]",
    `pub(crate) struct ${structName(schema.name)} {`,
    ...schemaFields.map(
      ({ fieldName, description, field }) =>
        `${description}\n    ${fieldName}: ${outputType(field)},`,
    ),
    "}\n",
  ];

  const impl = [
    "#[pymethods]",
    `impl ${structName(schema.name)} {`,
    `    #[new]`,
    `    fn new(`,
    ...schemaFields.map(({ argName, field }) => `        ${argName}: ${outputType(field)},`),
    `    ) -> Self {`,
    `        Self {`,
    ...schemaFields.map(({ fieldName, argName }) =>
      argName === fieldName
        ? // shorthand initialization
          `            ${fieldName},`
        : `            ${fieldName}: ${argName},`,
    ),
    "        }",
    "    }",
    "}\n\n",
  ];

  function from(field: FoxgloveMessageField) {
    switch (field.type.type) {
      case "primitive":
        if (field.type.name === "time" || field.type.name === "duration") {
          return `Some(value.${safeName(field.name)}.into())`;
        }
        return `value.${safeName(field.name)}`;
      case "nested":
        if (field.array) {
          return `value.${safeName(field.name)}.into_iter().map(|x| x.into()).collect()`;
        }
        return `Some(value.${safeName(field.name)}.into())`;
      case "enum":
        return `value.${safeName(field.name)} as i32`;
    }
  }

  const fromTrait = [
    `impl From<${structName(schema.name)}> for foxglove::schemas::${structName(schema.name)} {`,
    `    fn from(value: ${structName(schema.name)}) -> Self {`,
    `        Self {`,
    ...schemaFields.map(
      ({ fieldName, field }) => `            ${protoName(fieldName)}: ${from(field)},`,
    ),
    `        }`,
    `    }`,
    `}\n\n`,
  ];

  return [...struct, ...impl, ...fromTrait].join("\n");
}

function generateEnumClass(schema: FoxgloveEnumSchema): string {
  const enumLines = [
    descriptionComments(schema.description),
    `#[pyclass(eq, eq_int)]`,
    `#[derive(PartialEq, Clone)]`,
    `pub(crate) enum ${enumName(schema)} {`,
    ...schema.values.map((value) => `    ${constantToTitleCase(value.name)} = ${value.value},`),
    "}\n\n",
  ];

  return enumLines.join("\n");
}

/**
 * For enums with parent schemas, prepend the parent schema name to the enum name,
 * removing duplicated prefixes.
 */
function enumName(schema: FoxgloveEnumSchema): string {
  const name = schema.name.replace(new RegExp("^" + schema.parentSchemaName), "");
  return `${schema.parentSchemaName}${name}`;
}

/**
 * Deal with reserved keywords in identifiers
 */
function safeName(name: string): string {
  if (name === "type") {
    return "r#type";
  }
  return name;
}

/**
 * A schema is either a message schema or an enum.
 */
function isMessageSchema(schema: FoxgloveSchema): schema is FoxgloveMessageSchema {
  return schema.type === "message";
}

/**
 * Get the rust type for a field.
 * Types are assumed to be owned, and wrapped in a `Vec` if the field is an array.
 */
function outputType(field: FoxgloveMessageField): string {
  let type: string;
  switch (field.type.type) {
    case "primitive":
      type = rustType(field.type.name);
      break;
    case "nested":
      type = field.type.schema.name;
      break;
    case "enum":
      type = enumName(field.type.enum);
      break;
  }
  return field.array ? `Vec<${type}>` : type;
}

/**
 * Map Foxglove primitive types to rust primitives.
 */
function rustType(foxglovePrimitive: FoxglovePrimitive): string {
  switch (foxglovePrimitive) {
    case "string":
      return "String";
    case "float64":
      return "f64";
    case "uint32":
      return "u32";
    case "boolean":
      return "bool";
    case "bytes":
      return "Vec<u8>";
    case "time":
      return "Timestamp";
    case "duration":
      return "Duration";
  }
}

function protoName(name: string): string {
  if (name.match(/^[A-Z]$/)) {
    // Schemas may include single-letter capitals; generated proto structs use lowercase
    // todo: maybe want to expose lowercase names to python too
    return name.toLowerCase();
  }
  return name;
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function constantToTitleCase(str: string): string {
  return str
    .split("_")
    .map((word) => word.toLowerCase())
    .map(capitalize)
    .join("");
}

function structName(name: string): string {
  // Match special case handling in protobuf gen
  if (name === "GeoJSON") {
    return "GeoJson";
  }
  return name;
}

/**
 * Defines a struct for representing Timestamp and Duration.
 *
 * This also provides a `From` implementation into prost types for proto serialization.
 */
// todo: For Duration, would be nice to use the `std::time::Duration` type (but need a From impl)
export function generateTimeTypes(): string {
  return `
#[pyclass]
#[derive(Clone)]
pub struct Timestamp {
    pub seconds: i64,
    pub nanos: i32,
}

#[pymethods]
impl Timestamp {
    #[new]
    fn new(seconds: i64, nanos: i32) -> Self {
        Self { seconds, nanos }
    }
}

impl From<Timestamp> for prost_types::Timestamp {
    fn from(value: Timestamp) -> Self {
        Self {
            seconds: value.seconds,
            nanos: value.nanos,
        }
    }
}

#[pyclass]
#[derive(Clone)]
pub struct Duration {
    pub seconds: u64,
    pub nanos: u32,
}

#[pymethods]
impl Duration {
    #[new]
    fn new(seconds: u64, nanos: u32) -> Self {
        Self { seconds, nanos }
    }
}

impl From<Duration> for prost_types::Duration {
    fn from(value: Duration) -> Self {
        Self {
            // todo: prost should likely be configured to use unsigned types
            seconds: value.seconds.try_into().unwrap_or_default(),
            nanos: value.nanos.try_into().unwrap_or_default(),
        }
    }
}
`;
}
